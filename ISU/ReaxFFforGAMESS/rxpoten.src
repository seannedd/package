**********************************************************************
*                                                                    *
*     REAXFF Reactive force field program                            *
*                                                                    *
*     Developed and written by Adri van Duin, duin@wag.caltech.edu   *
*                                                                    *
*     Copyright (c) 2001-2010 California Institute of Technology     *
*                                                                    *
*     This is an open-source program. Feel free to modify its        *
*     contents. Please keep me informed of any useful modification   *
*     or addition that you made. Please do not distribute this       *
*     program to others; if people are interested in obtaining       *
*     a copy of this program let them contact me first.              *
*                                                                    *
**********************************************************************
******************************************************************** 


C*MODULE POTEN    *DECK CALVAL
C> @brief    valency angles and gradients
C>
C> @details  calculates valency angles and derivatives to cartesian coordinates 
C>
C> @author   Sean Nedd (implementation), Adri van Duin (original author), 2010-2012
C>
C> @date 11-11-14 - Sean A. Nedd
C>
      subroutine calval

********************************************************************** 
      include 'cbka.blk'
      dimension a(3),b(3),j(3),dradc(3,3),drbdc(3,3),dtdc(3,3),
     $dargdc(3,3),dndc(3,3),dadc(3),dbdc(3)
********************************************************************** 
*                                                                    *
*     Calculate valency angles and their derivatives to cartesian    *
*     coordinates                                                    *
*     Valency angle energies are calculated in valang                *
*                                                                    *
********************************************************************** 
      if (ndebug.eq.1) then
CSN   open (65,file='/u1/sean/gamessnew/ffparams/fort.65',
CSN  *      status='unknown',access='append')
CSN   write (65,*) 'In calval'
CSN   call timer(65)
CSN   close (65)

      CALL SEQOPN(365,'FORT65','UNKNOWN',.FALSE.,'FORMATTED')
      write (365,*) 'In calval'
      call timer(365)
      CALL SEQCLO(365,'KEEP')

      end if

      third=1.0d00/3.0d00
      twothird=2.0d00/3.0d00
      dadc(1)=-1.0d00
      dadc(2)=1.0d00
      dadc(3)=0.0d00
      dbdc(1)=0.0d00
      dbdc(2)=1.0d00
      dbdc(3)=-1.0d00
      do k1=1,3
      do k2=1,3
      dradc(k1,k2)=0.0d00
      drbdc(k1,k2)=0.0d00
      end do
      end do
      if (nval.eq.0) return
 
      do 10 i1=1,nval
      ity=iv(i1,1)
      j(1)=iv(i1,2)
      j(2)=iv(i1,3)
      j(3)=iv(i1,4)
**********************************************************************
*                                                                    *
*     Determine valency angle                                        *
*                                                                    *
**********************************************************************
      la=iv(i1,5)
      lb=iv(i1,6)
      ivl1=ibsym(la)
      ivl2=ibsym(lb)
      isign1=1
      isign2=1
      if (j(1).lt.j(2)) isign1=-1
      if (j(3).lt.j(2)) isign2=-1
      rla=rbo(la)
      rlb=rbo(lb)
      ix1=isign1*nvlx(ivl1)
      iy1=isign1*nvly(ivl1)
      iz1=isign1*nvlz(ivl1)
      ix2=isign2*nvlx(ivl2)
      iy2=isign2*nvly(ivl2)
      iz2=isign2*nvlz(ivl2)
 
*     call dista2(j(2),j(1),dis,a(1),a(2),a(3))
*     call dista2(j(2),j(3),dis,b(1),b(2),b(3))
      a(1)=c(j(2),1)-c(j(1),1)+ix1*tm11
      a(2)=c(j(2),2)-c(j(1),2)+ix1*tm21+iy1*tm22
      a(3)=c(j(2),3)-c(j(1),3)+ix1*tm31+iy1*tm32+iz1*tm33
      b(1)=c(j(2),1)-c(j(3),1)+ix2*tm11
      b(2)=c(j(2),2)-c(j(3),2)+ix2*tm21+iy2*tm22
      b(3)=c(j(2),3)-c(j(3),3)+ix2*tm31+iy2*tm32+iz2*tm33

      poem=rla*rlb
      tel=a(1)*b(1)+a(2)*b(2)+a(3)*b(3)
      arg=tel/poem
      arg2=arg*arg
      s1ma22=one-arg2
      if (s1ma22.lt.1.0d-10) s1ma22=1.0d-10
      s1ma2=sqrt(s1ma22)
      if (arg.gt.1.0d00) arg=1.0d00
      if (arg.lt.-1.0d00) arg=-1.0d00
      hl=acos(arg)
      h(i1)=hl
**********************************************************************
*                                                                    *
*     Calculate derivative valency angle to cartesian coordinates    *
*                                                                    *
**********************************************************************
      if (j(1).eq.ib(la,2)) then
      do k1=1,3
      dradc(k1,1)=drdc(la,k1,1)
      dradc(k1,2)=drdc(la,k1,2)
      end do
      else
      do k1=1,3
      dradc(k1,1)=drdc(la,k1,2)
      dradc(k1,2)=drdc(la,k1,1)
      end do
      end if
      if (j(2).eq.ib(lb,2)) then
      do k1=1,3
      drbdc(k1,2)=drdc(lb,k1,1)
      drbdc(k1,3)=drdc(lb,k1,2)
      end do
      else
      do k1=1,3
      drbdc(k1,2)=drdc(lb,k1,2)
      drbdc(k1,3)=drdc(lb,k1,1)
      end do
      end if
      do k1=1,3
      do k2=1,3
      dndc(k1,k2)=rla*drbdc(k1,k2)+rlb*dradc(k1,k2)
      dtdc(k1,k2)=a(k1)*dbdc(k2)+b(k1)*dadc(k2)
      dargdc(k1,k2)=(dtdc(k1,k2)-arg*dndc(k1,k2))/poem
      dhdc(i1,k1,k2)=-dargdc(k1,k2)/s1ma2
      end do
      end do
      
   10 continue

      return
      end
********************************************************************** 
********************************************************************** 

C*MODULE POTEN    *DECK BONCOR
C> @brief    over-coordination correction
C>
C> @details  correction for over-coordination and 1-3 bond orders 
C>
C> @author   Sean Nedd (implementation), Adri van Duin (original author), 2010-2012
C>
C> @date 11-11-14 - Sean A. Nedd
C>
      subroutine boncor

********************************************************************** 
      include 'cbka.blk'
      if (ndebug.eq.1) then
CSN   open (65,file='/u1/sean/gamessnew/ffparams/fort.65',
CSN  *      status='unknown',access='append')
CSN   write (65,*) 'In boncor'
CSN   call timer(65)
CSN   close (65)

      CALL SEQOPN(365,'FORT65','UNKNOWN',.FALSE.,'FORMATTED')
      write (365,*) 'In boncor'
      call timer(365)
      CALL SEQCLO(365,'KEEP')

      end if
********************************************************************** 
*                                                                    *
*     Correction for overcoordination and 1-3 bond orders            *
*                                                                    *
********************************************************************** 
      
      do 10 i1=1,nbon
      ibt=ib(i1,1)
      j1=ib(i1,2)
      j2=ib(i1,3)
      if (ovc(ibt).lt.0.001d00.and.v13cor(ibt).lt.0.001d00) then
      idbo1(i1)=2
      idbo(i1,1)=j1
      idbo(i1,2)=j2
      do k1=1,3
      dbondc(i1,k1,1)=dbodc(i1,k1,1)
      dbondc(i1,k1,2)=dbodc(i1,k1,2)
      dbosindc(i1,k1,1)=dbosidc(i1,k1,1)
      dbosindc(i1,k1,2)=dbosidc(i1,k1,2)
      dbopindc(i1,k1,1)=dbopidc(i1,k1,1)
      dbopindc(i1,k1,2)=dbopidc(i1,k1,2)
      dbopi2ndc(i1,k1,1)=dbopi2dc(i1,k1,1)
      dbopi2ndc(i1,k1,2)=dbopi2dc(i1,k1,2)
      end do
      goto 10
      end if
      boo=bo(i1)
      bopio=bopi(i1)
      bopi2o=bopi2(i1)
      iti=ia(j1,1)
      itj=ia(j2,1)
      aboi=abo(j1)
      aboj=abo(j2)
      vp131=sqrt(bo131(iti)*bo131(itj))
      vp132=sqrt(bo132(iti)*bo132(itj))
      vp133=sqrt(bo133(iti)*bo133(itj))
      corrtot=1.0d00
      dbodsboi1=zero
      dbodsboj1=zero
      if (ovc(ibt).gt.0.001d00) then
      ovi=aboi-aval(iti)
      ovj=aboj-aval(itj)

********************************************************************** 
*                                                                    *
*     Correction for overcoordination                                *
*                                                                    *
********************************************************************** 
      exphu1=exp(-vpar(2)*ovi)
      exphu2=exp(-vpar(2)*ovj)
      exp11=exp(-vpar(1)*ovi)
      exp21=exp(-vpar(1)*ovj)
      exphu12=(exphu1+exphu2)
      ovcor=-(1.0d00/vpar(2))*log(0.50d00*exphu12)
*     huli=((1.0d00/ovc(ibt))*aval(iti)+exp11+exp21)
*     hulj=((1.0d00/ovc(ibt))*aval(itj)+exp11+exp21)
      huli=aval(iti)+exp11+exp21
      hulj=aval(itj)+exp11+exp21
      corr1=huli/(huli+ovcor)
      corr2=hulj/(hulj+ovcor)
      corrtot=0.50d00*(corr1+corr2)

      dbodsboi1=0.50d00*(-vpar(1)*exp11/(huli+ovcor)-
     $(corr1/(huli+ovcor))*
     $(-vpar(1)*exp11+exphu1/exphu12)-vpar(1)*exp11/(hulj+ovcor)-
     $(corr2/(hulj+ovcor))*(-vpar(1)*exp11+exphu1/exphu12))
      dbodsboj1=0.50d00*(-vpar(1)*exp21/(huli+ovcor)-
     $(corr1/(huli+ovcor))*
     $(-vpar(1)*exp21+exphu2/exphu12)-vpar(1)*exp21/(hulj+ovcor)-
     $(corr2/(hulj+ovcor))*(-vpar(1)*exp21+exphu2/exphu12))
      end if
********************************************************************** 
*                                                                    *
*     Correction for 1-3 bond orders                                 *
*                                                                    *
********************************************************************** 
      dbodsboi2=zero
      dbodsboj2=zero
      bocor1=1.0d00
      bocor2=1.0d00
      if (v13cor(ibt).gt.0.001d00) then
*     ovi2=aboi-valf(iti)
*     ovj2=aboj-valf(itj)
      ovi2=aboi-vval3(iti)                           !Modification for Pt
      ovj2=aboj-vval3(itj)
*     ovi2=aboi-aval(iti)
*     ovj2=aboj-aval(itj)
      cor1=vp131*boo*boo-ovi2
      cor2=vp131*boo*boo-ovj2
*     exphu3=v13cor(ibt)*exp(-vp132*cor1+vp133)
*     exphu4=v13cor(ibt)*exp(-vp132*cor2+vp133)
      exphu3=exp(-vp132*cor1+vp133)
      exphu4=exp(-vp132*cor2+vp133)
      bocor1=1.0d00/(1.0d00+exphu3)
      bocor2=1.0d00/(1.0d00+exphu4)
      dbodsboi2=-bocor1*bocor1*bocor2*vp132*exphu3
      dbodsboj2=-bocor1*bocor2*bocor2*vp132*exphu4
      end if

      bo(i1)=boo*corrtot*bocor1*bocor2
      if (bo(i1).lt.1d-10) bo(i1)=zero
      corrtot2=corrtot*corrtot
      bopi(i1)=bopio*corrtot2*bocor1*bocor2
      bopi2(i1)=bopi2o*corrtot2*bocor1*bocor2
      if (bopi(i1).lt.1d-10) bopi(i1)=zero
      if (bopi2(i1).lt.1d-10) bopi2(i1)=zero

      dbodboo=corrtot*bocor1*bocor2+corrtot*
     $bocor1*bocor1*bocor2*boo*vp132*vp131*2.0d00*boo*exphu3+
     $corrtot*bocor1*bocor2*bocor2*boo*
     $vp132*vp131*exphu4*2.0d00*boo

      dbopidbopio=corrtot2*bocor1*bocor2

      dbopidboo=corrtot2*
     $bocor1*bocor1*bocor2*boo*vp132*vp131*2.0d00*bopio*exphu3+
     $corrtot2*bocor1*bocor2*bocor2*boo*
     $vp132*vp131*exphu4*2.0d00*bopio

      dbopi2dbopi2o=corrtot2*bocor1*bocor2

      dbopi2dboo=corrtot2*
     $bocor1*bocor1*bocor2*boo*vp132*vp131*2.0d00*bopi2o*exphu3+
     $corrtot2*bocor1*bocor2*bocor2*boo*
     $vp132*vp131*exphu4*2.0d00*bopi2o

      dbodsboit=boo*dbodsboi1*bocor1*bocor2+boo*corrtot*dbodsboi2
      dbodsbojt=boo*dbodsboj1*bocor1*bocor2+boo*corrtot*dbodsboj2

      vhui=2.0d00*corrtot*dbodsboi1*bocor1*bocor2+corrtot2*dbodsboi2
      vhuj=2.0d00*corrtot*dbodsboj1*bocor1*bocor2+corrtot2*dbodsboj2
      dbopidsboit=bopio*vhui
      dbopidsbojt=bopio*vhuj

      dbopi2dsboit=bopi2o*vhui
      dbopi2dsbojt=bopi2o*vhuj

********************************************************************** 
*                                                                    *
*     Calculate bond order derivatives                               *
*                                                                    *
********************************************************************** 
      idbo1(i1)=2+ia(j1,2)+ia(j2,2)
      idbo(i1,1)=j1
      idbo(i1,2)=j2
      nco=0
      do k1=1,3
      dbondc(i1,k1,1)=dbodc(i1,k1,1)*dbodboo
      dbondc(i1,k1,2)=dbodc(i1,k1,2)*dbodboo
*     dbosindc(i1,k1,1)=dbosidc(i1,k1,1)*dbosidboo
*     dbosindc(i1,k1,2)=dbosidc(i1,k1,2)*dbosidboo
      dbopindc(i1,k1,1)=dbopidc(i1,k1,1)*dbopidbopio+
     $dbodc(i1,k1,1)*dbopidboo
      dbopindc(i1,k1,2)=dbopidc(i1,k1,2)*dbopidbopio+
     $dbodc(i1,k1,2)*dbopidboo
      dbopi2ndc(i1,k1,1)=dbopi2dc(i1,k1,1)*dbopi2dbopi2o+
     $dbodc(i1,k1,1)*dbopi2dboo
      dbopi2ndc(i1,k1,2)=dbopi2dc(i1,k1,2)*dbopi2dbopi2o+
     $dbodc(i1,k1,2)*dbopi2dboo
      end do
      do i2=1,ia(j1,2)
      ihl=0
      iob=ia(j1,2+i2)
      if (iob.lt.j1) ihl=1
      ncubo=nubon2(j1,i2)
      idbo(i1,2+nco+1)=iob
      do k1=1,3
      dbondc(i1,k1,1)=dbondc(i1,k1,1)+dbodc(ncubo,k1,1+ihl)*dbodsboit
      dbondc(i1,k1,2+nco+1)=dbodc(ncubo,k1,2-ihl)*dbodsboit

*     dbosindc(i1,k1,1)=dbosindc(i1,k1,1)+
*    $dbodc(ncubo,k1,1+ihl)*dbosidsboit
*     dbosindc(i1,k1,2+nco+1)=dbodc(ncubo,k1,2-ihl)*dbosidsboit

      dbopindc(i1,k1,1)=dbopindc(i1,k1,1)+
     $dbodc(ncubo,k1,1+ihl)*dbopidsboit
      dbopindc(i1,k1,2+nco+1)=dbodc(ncubo,k1,2-ihl)*dbopidsboit

      dbopi2ndc(i1,k1,1)=dbopi2ndc(i1,k1,1)+
     $dbodc(ncubo,k1,1+ihl)*dbopi2dsboit
      dbopi2ndc(i1,k1,2+nco+1)=dbodc(ncubo,k1,2-ihl)*dbopi2dsboit

      end do
      nco=nco+1
      end do
      do i2=1,ia(j2,2)
      ihl=0
      iob=ia(j2,2+i2)
      if (iob.lt.j2) ihl=1
      ncubo=nubon2(j2,i2)
      idbo(i1,2+nco+1)=iob
      do k1=1,3

      dbondc(i1,k1,2)=dbondc(i1,k1,2)+dbodc(ncubo,k1,1+ihl)*dbodsbojt
      dbondc(i1,k1,2+nco+1)=dbodc(ncubo,k1,2-ihl)*dbodsbojt

*     dbosindc(i1,k1,2)=dbosindc(i1,k1,2)+
*    $dbodc(ncubo,k1,1+ihl)*dbosidsbojt
*     dbosindc(i1,k1,2+nco+1)=dbodc(ncubo,k1,2-ihl)*dbosidsbojt

      dbopindc(i1,k1,2)=dbopindc(i1,k1,2)+
     $dbodc(ncubo,k1,1+ihl)*dbopidsbojt
      dbopindc(i1,k1,2+nco+1)=dbodc(ncubo,k1,2-ihl)*dbopidsbojt

      dbopi2ndc(i1,k1,2)=dbopi2ndc(i1,k1,2)+
     $dbodc(ncubo,k1,1+ihl)*dbopi2dsbojt
      dbopi2ndc(i1,k1,2+nco+1)=dbodc(ncubo,k1,2-ihl)*dbopi2dsbojt

      end do
      nco=nco+1
      end do

   10 continue

      do i1=1,na
      abo(i1)=zero
      end do
*     do i1=1,na
*     do i2=1,ia(i1,2)
*     iob=ia(i1,2+i2)
*     ncubo=nubon2(i1,i2)
*     abo(i1)=abo(i1)+bo(ncubo)
*     end do
*     end do
      do i1=1,nbon
      j1=ib(i1,2)
      j2=ib(i1,3)
      abo(j1)=abo(j1)+bo(i1)
      if (j1.ne.j2) abo(j2)=abo(j2)+bo(i1)
      end do

   15 continue
      return
      end
********************************************************************** 
********************************************************************** 

C*MODULE POTEN    *DECK LONPAR
C> @brief    lone pair energy and gradients
C>
C> @details  calculate lone pair energy and first derivatives 
C>
C> @author   Sean Nedd (implementation), Adri van Duin (original author), 2010-2012
C>
C> @date 11-11-14 - Sean A. Nedd
C>
      subroutine lonpar

********************************************************************** 
      include 'cbka.blk'
      if (ndebug.eq.1) then
CSN   open (65,file='/u1/sean/gamessnew/ffparams/fort.65',
CSN  *      status='unknown',access='append')
CSN   write (65,*) 'In lonpar'
CSN   call timer(65)
CSN   close (65)

      CALL SEQOPN(365,'FORT65','UNKNOWN',.FALSE.,'FORMATTED')
      write (365,*) 'In lonpar'
      call timer(365)
      CALL SEQCLO(365,'KEEP')

      end if
      if (ioutta.eq.1) then
CSN   open (67,file='/u1/sean/gamessnew/ffparams/lonpar.dat',
CSN  *      status='unknown',access='append')
CSN   write (6,100)
CSN   write (67,100)

      CALL SEQOPN(367,'FORT:67','UNKNOWN',.FALSE.,'FORMATTED')
      write (367,100)

      end if
**********************************************************************
*                                                                    *
*     Calculate lone pair energy and first derivatives               *
*                                                                    *
**********************************************************************
      elp=zero
      do i1=1,na
**********************************************************************
*                                                                    *
*     Determine number of lone pairs on atoms
*                                                                    *
**********************************************************************
      ity=ia(i1,1)
      voptlp=0.50d00*(stlp(ity)-aval(ity))
      vlp(i1)=zero
      vund=abo(i1)-stlp(ity)
      vlph=2.0d00*int(vund/2.0d00)
      vlpex=vund-vlph
      vp16h=vpar(16)-1.0d00

      expvlp=exp(-vpar(16)*(2.0d00+vlpex)*(2.0d00+vlpex))
      dvlpdsbo(i1)=-vpar(16)*2.0d00*(2.0d00+vlpex)*expvlp
      vlp(i1)=expvlp-int(vund/2.0d00)
**********************************************************************
*                                                                    *
*     Calculate lone pair energy                                     *
*                                                                    *
**********************************************************************
      diffvlp=voptlp-vlp(i1)
      exphu1=exp(-75.0d00*diffvlp)
      hulp1=1.0d00/(1.0d00+exphu1)
      elph=vlp1(ity)*diffvlp*hulp1

CSN   if (ioutta.eq.1) write (7,'(i6,3f12.4)')i1,vlp(i1),
CSN  $elph,elp+elph
CSN   if (ioutta.eq.1) write (67,'(i6,3f12.4)')i1,vlp(i1),
CSN  $elph,elp+elph
      if (ioutta.eq.1) write (367,'(i6,3f12.4)')i1,vlp(i1),
     $elph,elp+elph

      estrain(i1)=estrain(i1)+elph
*     elph=vlp1(ity)*diffvlp
      delpdvlp=-vlp1(ity)*hulp1-vlp1(ity)*diffvlp*hulp1*hulp1*
     $75.0d00*exphu1
      elp=elp+elph
      delpdsbo=delpdvlp*dvlpdsbo(i1)
**********************************************************************
*                                                                    *
*     Calculate first derivative of lone pair energy to              *
*     cartesian coordinates                                          *
*                                                                    *
**********************************************************************
      if (icpres.eq.0) then
      do i3=1,ia(i1,2)
      iob=ia(i1,2+i3)
      ncubo=nubon2(i1,i3)
      do i4=1,idbo1(ncubo)
      ihu=idbo(ncubo,i4)
      do k1=1,3
      d(k1,ihu)=d(k1,ihu)+delpdsbo*dbondc(ncubo,k1,i4)
      end do
      end do
      end do
      else
      do i3=1,ia(i1,2)
      iob=ia(i1,2+i3)
      ncubo=nubon2(i1,i3)
      do i4=1,idbo1(ncubo)
      ihu=idbo(ncubo,i4)
      ix=nmpx(i1,ihu)
      iy=nmpy(i1,ihu)
      iz=nmpz(i1,ihu)
      kcell=14+ix+3*iy+9*iz
      do k1=1,3
      dcell(k1,ihu,kcell)=dcell(k1,ihu,kcell)+
     $delpdsbo*dbondc(ncubo,k1,i4)
      end do
      end do
      end do
      end if

      end do
   
CSN   if (ioutta.eq.1) close(67)
      if (ioutta.eq.1) CALL SEQCLO(367,'KEEP')

      return
  100 format ('  Atom1      #lp         Elp      sum(Elp)')
      end
********************************************************************** 
********************************************************************** 

C*MODULE POTEN    *DECK COVBON
C> @brief    bond energy and gradients
C>
C> @details  calculate bond energy and first derivatives 
C>
C> @author   Sean Nedd (implementation), Adri van Duin (original author), 2010-2012
C>
C> @date 11-11-14 - Sean A. Nedd
C>
      subroutine covbon

********************************************************************** 
      include 'cbka.blk'
********************************************************************** 
*                                                                    *
*     Calculate bond energy and first derivatives                    *
*                                                                    *
********************************************************************** 
      if (ndebug.eq.1) then
CSN   open (65,file='/u1/sean/gamessnew/ffparams/fort.65',
CSN  *      status='unknown',access='append')
CSN   write (65,*) 'In covbon'
CSN   call timer(65)
CSN   close (65)

      CALL SEQOPN(365,'FORT65','UNKNOWN',.FALSE.,'FORMATTED')
      write (365,*) 'In covbon'
      call timer(365)
      CALL SEQCLO(365,'KEEP')

      end if
      eb=0.0d00
CSN   write(6,*)'nbon is',nbon
      if (nbon.eq.0) return
      if (ioutta.eq.1) then
CSN   open (67,file='/u1/sean/gamessnew/ffparams/bonds.dat',
CSN  *      status='unknown',access='append')
CSN   write (6,100)
CSN   write (67,100)

      CALL SEQOPN(367,'FORT;67','UNKNOWN',.FALSE.,'FORMATTED')
      write (367,100)

CSN   open (68,file='/u1/sean/gamessnew/ffparams/triple.dat',
CSN  *      status='unknown',access='append')
CSN   write (6,200)
CSN   write (68,200)

      CALL SEQOPN(368,'FORT:68','UNKNOWN',.FALSE.,'FORMATTED')
      write (368,100)

      end if
********************************************************************** 
*                                                                    *
*     Calculate bond energies                                        *
*                                                                    *
********************************************************************** 
      do 20 i1=1,nbon

      boa=bo(i1)
*     if (boa.lt.cutof2) goto 20
      j1=ib(i1,2)
      j2=ib(i1,3)
      vsymm=1.0d00
      if (j1.eq.j2) vsymm=0.5d00

      bopia=bopi(i1)
      bopi2a=bopi2(i1)
      bosia=boa-bopia-bopi2a
      if (bosia.lt.zero) bosia=zero
      it1=ia(j1,1)
      it2=ia(j2,1)
      ibt=ib(i1,1)
      de1h=vsymm*de1(ibt)
      de2h=vsymm*de2(ibt)
      de3h=vsymm*de3(ibt)

      bopo1=bosia**psp(ibt)
      exphu1=exp(psi(ibt)*(1.0d00-bopo1))
      ebh=-de1h*bosia*exphu1-de2h*bopia-de3h*bopi2a
      estrain(j1)=estrain(j1)+0.50d00*ebh
      estrain(j2)=estrain(j2)+0.50d00*ebh
CSN   if (ioutta.eq.1) write (7,'(2i6,5f12.4)')j1,j2,boa,ebh,eb+ebh
CSN   if (ioutta.eq.1) write (67,'(2i6,5f12.4)')j1,j2,boa,ebh,eb+ebh
      if (ioutta.eq.1) write (367,'(2i6,5f12.4)')j1,j2,boa,ebh,eb+ebh

      debdbo=-de1h*exphu1+de1h*exphu1*psp(ibt)*psi(ibt)*bopo1
      debdbopi=-de2h
      debdbopi2=-de3h

      eb=eb+ebh

      if (icpres.eq.0) then
      do i2=1,idbo1(i1)
      ihu=idbo(i1,i2)
      do k1=1,3
      d(k1,ihu)=d(k1,ihu)+debdbo*(dbondc(i1,k1,i2)-dbopindc(i1,k1,i2)-
     $dbopi2ndc(i1,k1,i2))+
     $debdbopi*dbopindc(i1,k1,i2)+
     $debdbopi2*dbopi2ndc(i1,k1,i2)
      end do
      end do
      else
      do i2=1,idbo1(i1)
      ihu=idbo(i1,i2)
      ix=nmpx(j1,ihu)
      iy=nmpy(j1,ihu)
      iz=nmpz(j1,ihu)
      kcell=14+ix+3*iy+9*iz
      do k1=1,3
      dcell(k1,ihu,kcell)=dcell(k1,ihu,kcell)+debdbo*
     $(dbondc(i1,k1,i2)-dbopindc(i1,k1,i2)-dbopi2ndc(i1,k1,i2))+
     $debdbopi*dbopindc(i1,k1,i2)+
     $debdbopi2*dbopi2ndc(i1,k1,i2)
      end do
      end do
      end if
**********************************************************************
*                                                                    *
*     Stabilisation terminal triple bond                             *
*                                                                    *
**********************************************************************
      if (boa.lt.1.0d00) goto 20
*     if ((qa(j1).eq.'C '.and.qa(j2).eq.'O ').or.         !for ReaxFF_CHO: only apply to C-O triple bond
*    $(qa(j1).eq.'O '.and.qa(j2).eq.'C ')) then

      ba=(boa-2.50d00)*(boa-2.50d00)
      exphu=exp(-vpar(8)*ba)
      oboa=abo(j1)-boa
      obob=abo(j2)-boa
      exphua1=exp(-vpar(4)*oboa)
      exphub1=exp(-vpar(4)*obob)
      ovoab=abo(j1)-aval(it1)+abo(j2)-aval(it2)
      exphuov=exp(vpar(5)*ovoab)
      hulpov=1.0d00/(1.0d00+25.0d00*exphuov)
      
      estriph=vpar(11)*exphu*hulpov*(exphua1+exphub1)
CSN   if (ioutta.eq.1) write (7,'(2i6,5f12.4)')j1,j2,boa,estriph,
CSN  $eb+estriph
CSN   if (ioutta.eq.1) write (68,'(2i6,5f12.4)')j1,j2,boa,estriph,
CSN  $eb+estriph
      if (ioutta.eq.1) write (368,'(2i6,5f12.4)')j1,j2,boa,estriph,
     $eb+estriph
      estrain(j1)=estrain(j1)+0.50d00*estriph
      estrain(j2)=estrain(j2)+0.50d00*estriph
      eb=eb+estriph

      decobdbo=vpar(4)*vpar(11)*exphu*hulpov*(exphua1+exphub1)
     $-2.0d00*vpar(11)*vpar(8)*(boa-2.50d00)*hulpov*exphu*
     $(exphua1+exphub1)
      decobdboua=-25.0d00*vpar(5)*vpar(11)*exphu*exphuov*hulpov*hulpov*
     $(exphua1+exphub1)-vpar(11)*exphu*vpar(4)*hulpov*exphua1
      decobdboub=-25.0d00*vpar(5)*vpar(11)*exphu*exphuov*hulpov*hulpov*
     $(exphua1+exphub1)-vpar(11)*exphu*vpar(4)*hulpov*exphub1

      if (icpres.eq.0) then

      do i2=1,idbo1(i1)
      ihu=idbo(i1,i2)
      do k1=1,3
      d(k1,ihu)=d(k1,ihu)+decobdbo*dbondc(i1,k1,i2)
      end do
      end do

      do i3=1,ia(j1,2)
      iob=ia(j1,2+i3)
      ncubo=nubon2(j1,i3)
      do i4=1,idbo1(ncubo)
      ihu=idbo(ncubo,i4)
      do k1=1,3
      d(k1,ihu)=d(k1,ihu)+decobdboua*dbondc(ncubo,k1,i4)
      end do
      end do
      end do

      do i3=1,ia(j2,2)
      iob=ia(j2,2+i3)
      ncubo=nubon2(j2,i3)
      do i4=1,idbo1(ncubo)
      ihu=idbo(ncubo,i4)
      do k1=1,3
      d(k1,ihu)=d(k1,ihu)+decobdboub*dbondc(ncubo,k1,i4)
      end do
      end do
      end do

      else

      do i2=1,idbo1(i1)
      ihu=idbo(i1,i2)
      ix=nmpx(j1,ihu)
      iy=nmpy(j1,ihu)
      iz=nmpz(j1,ihu)
      kcell=14+ix+3*iy+9*iz
      do k1=1,3
      dcell(k1,ihu,kcell)=dcell(k1,ihu,kcell)+
     $decobdbo*dbondc(i1,k1,i2)
      end do
      end do

      do i3=1,ia(j1,2)
      iob=ia(j1,2+i3)
      ncubo=nubon2(j1,i3)
      do i4=1,idbo1(ncubo)
      ihu=idbo(ncubo,i4)
      ix=nmpx(j1,ihu)
      iy=nmpy(j1,ihu)
      iz=nmpz(j1,ihu)
      kcell=14+ix+3*iy+9*iz
      do k1=1,3
      dcell(k1,ihu,kcell)=dcell(k1,ihu,kcell)+
     $decobdboua*dbondc(ncubo,k1,i4)
      end do
      end do
      end do

      do i3=1,ia(j2,2)
      iob=ia(j2,2+i3)
      ncubo=nubon2(j2,i3)
      do i4=1,idbo1(ncubo)
      ihu=idbo(ncubo,i4)
      ix=nmpx(j1,ihu)
      iy=nmpy(j1,ihu)
      iz=nmpz(j1,ihu)
      kcell=14+ix+3*iy+9*iz
      do k1=1,3
      dcell(k1,ihu,kcell)=dcell(k1,ihu,kcell)+
     $decobdboub*dbondc(ncubo,k1,i4)
      end do
      end do
      end do

      end if
*     end if                                     !for ReaxFF_CHO: only apply to CO triple bond

   20 continue

      if (ioutta.eq.1) then
CSN   close(67)
CSN   close(68)

      CALL SEQCLO(367,'KEEP')
      CALL SEQCLO(368,'KEEP')

      end if
      return
  100 format ('  Atom1  Atom2      BO         Eb       sum(Eb)')
  200 format ('  Atom1  Atom2      BO        Etrip   sum(Eb+Etrip)')
      end
********************************************************************** 
********************************************************************** 

C*MODULE POTEN    *DECK OVCOR
C> @brief    atom energy and coordination 
C>
C> @details  calculate atom energy and 
C>           correction for over- and under-coordinated atoms 
C>
C> @author   Sean Nedd (implementation), Adri van Duin (original author), 2010-2012
C>
C> @date 11-11-14 - Sean A. Nedd
C>
      subroutine ovcor

********************************************************************** 
      include 'cbka.blk'
********************************************************************** 
*                                                                    *
*     Calculate atom energy                                          *
*     Correction for over- and undercoordinated atoms                *
*                                                                    *
********************************************************************** 
      dimension vlptemp(natf)
      if (ndebug.eq.1) then
CSN   open (65,file='/u1/sean/gamessnew/ffparams/fort.65',
CSN  *      status='unknown',access='append')
CSN   write (65,*) 'In ovcor'
CSN   call timer(65)
CSN   close (65)

      CALL SEQOPN(365,'FORT65','UNKNOWN',.FALSE.,'FORMATTED')
      write (365,*) 'In ovcor'
      call timer(365)
      CALL SEQCLO(365,'KEEP')

      end if

      if (ioutta.eq.1) then
CSN   open (67,file='/u1/sean/gamessnew/ffparams/overco.dat',
CSN  *      status='unknown',access='append')
CSN   write (67,100)

      CALL SEQOPN(367,'FORT>67','UNKNOWN',.FALSE.,'FORMATTED')
      write (367,100)

CSN   open (68,file='/u1/sean/gamessnew/ffparams/underco.dat',
CSN  *      status='unknown',access='append')
CSN   write (68,200)

      CALL SEQOPN(368,'FORT>68','UNKNOWN',.FALSE.,'FORMATTED')
      write (368,200)

CSN   open (69,file='/u1/sean/gamessnew/ffparams/C2_corr.dat',
CSN  *      status='unknown',access='append')
CSN   write (69,300)

      CALL SEQOPN(369,'FORT;69','UNKNOWN',.FALSE.,'FORMATTED')
      write (369,300)

      end if

      do i1=1,na
      ity1=ia(i1,1)
      vlptemp(i1)=vlp(i1)
      if (amas(ity1).gt.21.0d00) 
     *vlptemp(i1)=0.50d00*(stlp(ity1)-aval(ity1))  !Only for 1st-row elements
      end do
   25 ea=zero
      eaot=zero
      eaut=zero

      do 30 i1=1,na
      ity1=ia(i1,1)
      dfvl=1.0d00                         
      if (amas(ity1).gt.21.0d00) dfvl=0.0d00  !Only for 1st-row elements
********************************************************************** 
*                                                                    *
*     Calculate overcoordination energy                              *
*     Valency is corrected for lone pairs                            *
*                                                                    *
********************************************************************** 
      voptlp=0.50d00*(stlp(ity1)-aval(ity1))
      diffvlph=dfvl*(voptlp-vlptemp(i1))
********************************************************************** 
*                                                                    *
*     Determine coordination neighboring atoms                       *
*                                                                    *
********************************************************************** 
      sumov=0.0d00
      sumov2=0.0d00
      do i3=1,ia(i1,2)
      iat2=ia(i1,2+i3)
      ity2=ia(iat2,1)
      ncubo=nubon2(i1,i3)
      ibt=ib(ncubo,1)
      voptlp2=0.50d00*(stlp(ity2)-aval(ity2))
      diffvlp2=dfvl*(voptlp2-vlptemp(iat2))
      sumov=sumov+(bopi(ncubo)+bopi2(ncubo))*
     $(abo(iat2)-aval(ity2)-diffvlp2)
      sumov2=sumov2+vover(ibt)*de1(ibt)*bo(ncubo)
      end do

      exphu1=exp(vpar(32)*sumov)
      vho=1.0d00/(1.0d00+vpar(33)*exphu1)
      diffvlp=diffvlph*vho
      
      vov1=abo(i1)-aval(ity1)-diffvlp
      dvov1dsumov=diffvlph*vpar(32)*vpar(33)*vho*vho*exphu1
      exphuo=exp(vovun(ity1)*vov1)
      hulpo=1.0d00/(1.0d00+exphuo)

      hulpp=(1.0d00/(vov1+aval(ity1)+1d-8))

      eah=sumov2*hulpp*hulpo*vov1
CSN   if (ioutta.eq.1) write (67,'(i6,3f12.4)')i1,abo(i1),eah,ea+eah
      if (ioutta.eq.1) write (367,'(i6,3f12.4)')i1,abo(i1),eah,ea+eah
      estrain(i1)=estrain(i1)+eah
      deadvov1=-sumov2*hulpp*hulpp*vov1*hulpo+
     $sumov2*hulpp*hulpo-sumov2*hulpp*vov1*vovun(ity1)*
     $hulpo*hulpo*exphuo
      ea=ea+eah

********************************************************************** 
*                                                                    *
*     Calculate first derivative of overcoordination energy to       *
*     cartesian coordinates                                          *
*                                                                    *
********************************************************************** 
      if (icpres.eq.0) then

      do i3=1,ia(i1,2)
      iob=ia(i1,2+i3)
      ncubo=nubon2(i1,i3)
      ibt=ib(ncubo,1)
      deadbo=vover(ibt)*de1(ibt)*hulpp*hulpo*vov1
      do i4=1,idbo1(ncubo)
      ihu=idbo(ncubo,i4)
      do k1=1,3
      d(k1,ihu)=d(k1,ihu)+deadvov1*(1.0d00+dfvl*vho*dvlpdsbo(i1))*
     $dbondc(ncubo,k1,i4)+deadbo*dbondc(ncubo,k1,i4)
      end do
      end do
      end do
 
      do i2=1,ia(i1,2)
 
      iat2=ia(i1,2+i2)
      ity2=ia(iat2,1)
      nbosa=nubon2(i1,i2)
      deadvov2=deadvov1*dvov1dsumov*(bopi(nbosa)+bopi2(nbosa))
 
      voptlp2=0.50d00*(stlp(ity2)-aval(ity2))
      diffvlp2=dfvl*(voptlp2-vlptemp(iat2))
      deadpibo=deadvov1*dvov1dsumov*(abo(iat2)-aval(ity2)-diffvlp2)
 
      do i4=1,idbo1(nbosa)
      ihu=idbo(nbosa,i4)
      do k1=1,3
      d(k1,ihu)=d(k1,ihu)+deadpibo*(dbopindc(nbosa,k1,i4)+
     $dbopi2ndc(nbosa,k1,i4))
      end do
      end do
 
      do i3=1,ia(iat2,2)
      iob=ia(iat2,2+i3)
      ncubo=nubon2(iat2,i3)
      do i4=1,idbo1(ncubo)
      ihu=idbo(ncubo,i4)
      do k1=1,3
      d(k1,ihu)=d(k1,ihu)+deadvov2*(1.0d00+dfvl*dvlpdsbo(iat2))*
     $dbondc(ncubo,k1,i4)
      end do
      end do
      end do
 
      end do

      else

      do i3=1,ia(i1,2)
      iob=ia(i1,2+i3)
      ncubo=nubon2(i1,i3)
      ibt=ib(ncubo,1)
      deadbo=vover(ibt)*de1(ibt)*hulpp*hulpo*vov1
      do i4=1,idbo1(ncubo)
      ihu=idbo(ncubo,i4)
      ix=nmpx(i1,ihu)
      iy=nmpy(i1,ihu)
      iz=nmpz(i1,ihu)
      kcell=14+ix+3*iy+9*iz
      do k1=1,3
      dcell(k1,ihu,kcell)=dcell(k1,ihu,kcell)+deadvov1*
     $(1.0d00+dfvl*vho*dvlpdsbo(i1))*
     $dbondc(ncubo,k1,i4)+deadbo*dbondc(ncubo,k1,i4)
      end do
      end do
      end do

      do i2=1,ia(i1,2)

      iat2=ia(i1,2+i2)
      ity2=ia(iat2,1)
      nbosa=nubon2(i1,i2)
      deadvov2=deadvov1*dvov1dsumov*(bopi(nbosa)+bopi2(nbosa))

      voptlp2=0.50d00*(stlp(ity2)-aval(ity2))
      diffvlp2=dfvl*(voptlp2-vlptemp(iat2))
      deadpibo=deadvov1*dvov1dsumov*(abo(iat2)-aval(ity2)-diffvlp2)

      do i4=1,idbo1(nbosa)
      ihu=idbo(nbosa,i4)
      ix=nmpx(i1,ihu)
      iy=nmpy(i1,ihu)
      iz=nmpz(i1,ihu)
      kcell=14+ix+3*iy+9*iz
      do k1=1,3
      dcell(k1,ihu,kcell)=dcell(k1,ihu,kcell)+deadpibo*
     $(dbopindc(nbosa,k1,i4)+dbopi2ndc(nbosa,k1,i4))
      end do
      end do

      do i3=1,ia(iat2,2)
      iob=ia(iat2,2+i3)
      ncubo=nubon2(iat2,i3)
      do i4=1,idbo1(ncubo)
      ihu=idbo(ncubo,i4)
      ix=nmpx(i1,ihu)
      iy=nmpy(i1,ihu)
      iz=nmpz(i1,ihu)
      kcell=14+ix+3*iy+9*iz
      do k1=1,3
      dcell(k1,ihu,kcell)=dcell(k1,ihu,kcell)+deadvov2*
     $(1.0d00+dfvl*dvlpdsbo(iat2))*dbondc(ncubo,k1,i4)
      end do
      end do
      end do

      end do
      end if

********************************************************************** 
*                                                                    *
*     Calculate undercoordination energy                             *
*                                                                    *
********************************************************************** 
      if (valp1(ity1).lt.zero) goto 30  !skip undercoordination
      exphu2=exp(vpar(10)*sumov)
      vuhu1=1.0d00+vpar(9)*exphu2
      hulpu2=1.0d00/vuhu1

      exphu3=-exp(vpar(7)*vov1)
      hulpu3=-(1.0d00+exphu3)

      dise2=valp1(ity1)
      exphuu=exp(-vovun(ity1)*vov1)
      hulpu=1.0d00/(1.0d00+exphuu)
      eahu=dise2*hulpu*hulpu2*hulpu3
CSN   if (ioutta.eq.1) write (68,'(i6,3f12.4)')i1,abo(i1),eahu,ea+eahu
      if (ioutta.eq.1) write (368,'(i6,3f12.4)')i1,abo(i1),eahu,ea+eahu
      estrain(i1)=estrain(i1)+eahu
      deaudvov1=dise2*hulpu2*vovun(ity1)*hulpu*hulpu*exphuu*hulpu3-
     $dise2*hulpu*hulpu2*vpar(7)*exphu3
      ea=ea+eahu
      deaudsumov=-dise2*hulpu*vpar(9)*vpar(10)*hulpu3*exphu2*
     $hulpu2*hulpu2

********************************************************************** 
*                                                                    *
*     Calculate first derivative of atom energy to cartesian         *
*     coordinates                                                    *
*                                                                    *
********************************************************************** 
      if (icpres.eq.0) then

      do i3=1,ia(i1,2)
      iob=ia(i1,2+i3)
      ncubo=nubon2(i1,i3)
      do i4=1,idbo1(ncubo)
      ihu=idbo(ncubo,i4)
      do k1=1,3
      d(k1,ihu)=d(k1,ihu)+deaudvov1*(1.0d00+dfvl*vho*dvlpdsbo(i1))*
     $dbondc(ncubo,k1,i4)
      end do
      end do
      end do
 
      do i2=1,ia(i1,2)
 
      iat2=ia(i1,2+i2)
      ity2=ia(iat2,1)
      nbosa=nubon2(i1,i2)
      deadvov2=(deaudsumov+dvov1dsumov*deaudvov1)*
     $(bopi(nbosa)+bopi2(nbosa))
 
      voptlp2=0.50d00*(stlp(ity2)-aval(ity2))
      diffvlp2=dfvl*(voptlp2-vlptemp(iat2))
      deadpibo1=(dvov1dsumov*deaudvov1+deaudsumov)*
     $(abo(iat2)-aval(ity2)-diffvlp2)
 
      do i4=1,idbo1(nbosa)
      ihu=idbo(nbosa,i4)
      do k1=1,3
      d(k1,ihu)=d(k1,ihu)+deadpibo1*
     $(dbopindc(nbosa,k1,i4)+dbopi2ndc(nbosa,k1,i4))
      end do
      end do
 
      do i3=1,ia(iat2,2)
      iob=ia(iat2,2+i3)
      ncubo=nubon2(iat2,i3)
      do i4=1,idbo1(ncubo)
      ihu=idbo(ncubo,i4)
      do k1=1,3
      d(k1,ihu)=d(k1,ihu)+deadvov2*(1.0d00+dfvl*dvlpdsbo(iat2))*
     $dbondc(ncubo,k1,i4)
      end do
      end do
      end do
 
      end do

      else

      do i3=1,ia(i1,2)
      iob=ia(i1,2+i3)
      ncubo=nubon2(i1,i3)
      do i4=1,idbo1(ncubo)
      ihu=idbo(ncubo,i4)
      ix=nmpx(i1,ihu)
      iy=nmpy(i1,ihu)
      iz=nmpz(i1,ihu)
      kcell=14+ix+3*iy+9*iz
      do k1=1,3
      dcell(k1,ihu,kcell)=dcell(k1,ihu,kcell)+deaudvov1*
     $(1.0d00+dfvl*vho*dvlpdsbo(i1))*dbondc(ncubo,k1,i4)
      end do
      end do
      end do

      do i2=1,ia(i1,2)

      iat2=ia(i1,2+i2)
      ity2=ia(iat2,1)
      nbosa=nubon2(i1,i2)
      deadvov2=(deaudsumov+dvov1dsumov*deaudvov1)*
     $(bopi(nbosa)+bopi2(nbosa))

      voptlp2=0.50d00*(stlp(ity2)-aval(ity2))
      diffvlp2=dfvl*(voptlp2-vlptemp(iat2))
      deadpibo1=(dvov1dsumov*deaudvov1+deaudsumov)*
     $(abo(iat2)-aval(ity2)-diffvlp2)

      do i4=1,idbo1(nbosa)
      ihu=idbo(nbosa,i4)
      ix=nmpx(i1,ihu)
      iy=nmpy(i1,ihu)
      iz=nmpz(i1,ihu)
      kcell=14+ix+3*iy+9*iz
      do k1=1,3
      dcell(k1,ihu,kcell)=dcell(k1,ihu,kcell)+deadpibo1*
     $(dbopindc(nbosa,k1,i4)+dbopi2ndc(nbosa,k1,i4))
      end do
      end do

      do i3=1,ia(iat2,2)
      iob=ia(iat2,2+i3)
      ncubo=nubon2(iat2,i3)
      do i4=1,idbo1(ncubo)
      ihu=idbo(ncubo,i4)
      ix=nmpx(i1,ihu)
      iy=nmpy(i1,ihu)
      iz=nmpz(i1,ihu)
      kcell=14+ix+3*iy+9*iz
      do k1=1,3
      dcell(k1,ihu,kcell)=dcell(k1,ihu,kcell)+deadvov2*
     $(1.0d00+dfvl*dvlpdsbo(iat2))*dbondc(ncubo,k1,i4)
      end do
      end do
      end do

      end do

      end if

   30 continue
 
**********************************************************************
*                                                                    *
*     Calculate correction for MgH                                   *
*                                                                    *
**********************************************************************
*     emgh=zero
*     do 39 i1=1,na
*     ity1=ia(i1,1)
*     vov4=abo(i1)-aval(ity1)
*
*     do i2=1,ia(i1,2)
*     iat2=ia(i1,2+i2)
*     nbohu=nubon2(i1,i2)
*
*     ibt=ib(nbohu,1)
*     vc2=vuncor(ibt)
*     elph=zero
*     deahu2dbo=zero
*     deahu2dsbo=zero
*     vov3=bo(nbohu)-vov4-vpar(14)*(vov4**4)
*     if (vov3.gt.1.0) then
*     elph=vc2*(vov3-1.0)*(vov3-1.0)
*     estrain(i1)=estrain(i1)+elph
*     deahu2dbo=2.0*vc2*(vov3-1.0)
*     deahu2dsbo=2.0*vc2*(vov3-1.0)*(-1.0-
*    $4.0*vpar(14)*(vov4**3))
*     end if
*
*     emgh=emgh+elph
*
*     do i3=1,idbo1(nbohu)
*     ihu=idbo(nbohu,i3)
*     do k1=1,3
*     d(k1,ihu)=d(k1,ihu)+deahu2dbo*dbondc(nbohu,k1,i3)
*     end do
*     end do
*
*     do i3=1,ia(i1,2)
*     iob=ia(i1,2+i3)
*     ncubo=nubon2(i1,i3)
*     do i4=1,idbo1(ncubo)
*     ihu=idbo(ncubo,i4)
*     do k1=1,3
*     d(k1,ihu)=d(k1,ihu)+deahu2dsbo*dbondc(ncubo,k1,i4)
*     end do
*     end do
*     end do
*
*     end do
*
*  39 continue
*     elp=elp+emgh
**********************************************************************
*                                                                    *
*     Calculate correction for C2                                    *
*                                                                    *
**********************************************************************

      if (abs(vpar(6)).gt.0.001d00) then
      do 40 i1=1,na
      ity1=ia(i1,1)
      vov4=abo(i1)-aval(ity1)
 
      do i2=1,ia(i1,2)


      iat2=ia(i1,2+i2)
      if (qa(i1).eq.'C '.and.qa(iat2).eq.'C ') then
      nbohu=nubon2(i1,i2)
 
      ibt=ib(nbohu,1)
      elph=zero
      deahu2dbo=zero
      deahu2dsbo=zero
      vov3=bo(nbohu)-vov4-0.040d00*(vov4**4)
      if (vov3.gt.3.0d00) then
      elph=vpar(6)*(vov3-3.0d00)*(vov3-3.0d00)
CSN   if (ioutta.eq.1) write (69,'(2i6,4f12.4)')i1,i2,bo(nbohu),vov4,
CSN  $elph,elp+elph
      if (ioutta.eq.1) write (369,'(2i6,4f12.4)')i1,i2,bo(nbohu),vov4,
     $elph,elp+elph
      estrain(i1)=estrain(i1)+elph
      deahu2dbo=2.0d00*vpar(6)*(vov3-3.0d00)
      deahu2dsbo=2.0d00*vpar(6)*(vov3-3.0d00)*(-1.0d00-
     $0.16d00*(vov4**3))
      end if
 
      elp=elp+elph
 
      if (icpres.eq.0) then
      do i3=1,idbo1(nbohu)
      ihu=idbo(nbohu,i3)
      do k1=1,3
      d(k1,ihu)=d(k1,ihu)+deahu2dbo*dbondc(nbohu,k1,i3)
      end do
      end do
 
      do i3=1,ia(i1,2)
      iob=ia(i1,2+i3)
      ncubo=nubon2(i1,i3)
      do i4=1,idbo1(ncubo)
      ihu=idbo(ncubo,i4)
      do k1=1,3
      d(k1,ihu)=d(k1,ihu)+deahu2dsbo*dbondc(ncubo,k1,i4)
      end do
      end do
      end do

      else

      do i3=1,idbo1(nbohu)
      ihu=idbo(nbohu,i3)
      ix=nmpx(i1,ihu)
      iy=nmpy(i1,ihu)
      iz=nmpz(i1,ihu)
      kcell=14+ix+3*iy+9*iz
      do k1=1,3
      dcell(k1,ihu,kcell)=dcell(k1,ihu,kcell)+
     $deahu2dbo*dbondc(nbohu,k1,i3)
      end do
      end do
 
      do i3=1,ia(i1,2)
      iob=ia(i1,2+i3)
      ncubo=nubon2(i1,i3)
      do i4=1,idbo1(ncubo)
      ihu=idbo(ncubo,i4)
      ix=nmpx(i1,ihu)
      iy=nmpy(i1,ihu)
      iz=nmpz(i1,ihu)
      kcell=14+ix+3*iy+9*iz
      do k1=1,3
      dcell(k1,ihu,kcell)=dcell(k1,ihu,kcell)+
     $deahu2dsbo*dbondc(ncubo,k1,i4)
      end do
      end do
      end do

      end if

      end if
      end do

 
   40 continue
      end if

      if (ioutta.eq.1) then
CSN   close(67)
CSN   close(68)
CSN   close(69)

      CALL SEQCLO(367,'KEEP')
      CALL SEQCLO(368,'KEEP')
      CALL SEQCLO(369,'KEEP')

      end if
      return
  100 format ('   Atom     sumBO      Eover    sum(Eover+Eunder)')
  200 format ('   Atom     sumBO      Eunder   sum(Eover+Eunder)')
  300 format ('  Atom1  Atom2      BO      ',
     $'  sumBO       E_C2   sum(Elp+E_C2)')
      end
**********************************************************************
********************************************************************** 

C*MODULE POTEN    *DECK MOLEN
C> @brief    molecular energy and gradients
C>
C> @details  calculate molecular energy and and first derivatives
C>           to prevent creating virtual electrons 
C>
C> @author   Sean Nedd (implementation), Adri van Duin (original author), 2010-2012
C>
C> @date 11-11-14 - Sean A. Nedd
C>
      subroutine molen

********************************************************************** 
      include 'cbka.blk'
********************************************************************** 
*                                                                    *
*     Calculate molecular energy and first derivatives               *
*     Only used to prevent creating virtual electrons                *
*                                                                    *
********************************************************************** 
      if (ndebug.eq.1) then
CSN   open (65,file='/u1/sean/gamessnew/ffparams/fort.65',
CSN  *      status='unknown',access='append')
CSN   write (65,*) 'In molen'
CSN   call timer(65)
CSN   close (65)

      CALL SEQOPN(365,'FORT65','UNKNOWN',.FALSE.,'FORMATTED')
      write (365,*) 'In molen'
      call timer(365)
      CALL SEQCLO(365,'KEEP')

      end if
      emol=zero
c     return
      do i1=1,nmolo

      enelm=0.0d00
      do i2=1,na
      if (ia(i2,3+mbond).eq.i1) then
      it1=ia(i2,1)
      enelm=enelm+aval(it1)
      end if
      end do

      na1m=nmolat(i1,1)

      enelm=2*int(enelm*0.50d00)
*     enelm=elmol(i1)
      bomsum=zero
      do i2=1,na1m
      ihu=nmolat(i1,i2+1)
      do i3=1,ia(ihu,2)
      ihu2=nubon2(ihu,i3)
      bomsum=bomsum+bo(ihu2)
      end do
      end do
      diff=(bomsum-enelm)
      exphu=exp(-vpar(37)*diff)
      exphu2=1.0d00/(1.0d00+15.0d00*exphu)
      emolh=zero
      demoldsbo=zero
      emolh=vpar(38)*exphu2
      emol=emol+emolh
      demoldsbo=vpar(38)*vpar(37)*15.0d00*exphu2*exphu2*exphu

      do i2=1,na1m
      ihu1=nmolat(i1,i2+1)
      do i3=1,ia(ihu1,2)
      iob=ia(ihu1,2+i3)
      ncubo=nubon2(ihu1,i3)
      do i4=1,idbo1(ncubo)
      ihu=idbo(ncubo,i4)
      do k1=1,3
      d(k1,ihu)=d(k1,ihu)+demoldsbo*dbondc(ncubo,k1,i4)
      end do
      end do
      end do
      end do


      end do


      return
      end
********************************************************************** 
********************************************************************** 

C*MODULE POTEN    *DECK VALANG
C> @brief    valency angle energies and gradients
C>
C> @details  calculates valency angle energies and first derivatives
C> 
C> @author   Sean Nedd (implementation), Adri van Duin (original author), 2010-2012
C>
C> @date 11-11-14 - Sean A. Nedd
C>
      subroutine valang

********************************************************************** 
      include 'cbka.blk'
      dimension j(3)
********************************************************************** 
*                                                                    *
*     Calculate valency angle energies and first derivatives         *
*                                                                    *
********************************************************************** 
      if (ndebug.eq.1) then
CSN   open (65,file='/u1/sean/gamessnew/ffparams/fort.65',
CSN  *      status='unknown',access='append')
CSN   write (65,*) 'In valang'
CSN   call timer(65)
CSN   close (65)

      CALL SEQOPN(365,'FORT65','UNKNOWN',.FALSE.,'FORMATTED')
      write (365,*) 'In valang'
      call timer(365)
      CALL SEQCLO(365,'KEEP')

      end if

      if (ioutta.eq.1) then
CSN   open (67,file='/u1/sean/gamessnew/ffparams/angle.dat',
CSN  *      status='unknown',access='append')
CSN   write (67,100)

      CALL SEQOPN(367,'FORT<67','UNKNOWN',.FALSE.,'FORMATTED')
      write (367,100)

CSN   open (68,file='/u1/sean/gamessnew/ffparams/penalty.dat',
CSN  *      status='unknown',access='append')
CSN   write (68,200)

      CALL SEQOPN(368,'FORT<68','UNKNOWN',.FALSE.,'FORMATTED')
      write (368,100)

CSN   open (69,file='/u1/sean/gamessnew/ffparams/13conj.dat',
CSN  *      status='unknown',access='append')
CSN   write (69,300)

      CALL SEQOPN(369,'FORT>69','UNKNOWN',.FALSE.,'FORMATTED')
      write (369,100)

      end if
    
*     eco=0.0d00
      ev=0.0d00
      ecoa=0.0d00
      epen=0.0d00
      if (nval.eq.0) return

      do 10 i1=1,nval
      ity=iv(i1,1)
      j(1)=iv(i1,2)
      j(2)=iv(i1,3)
      j(3)=iv(i1,4)

      la=iv(i1,5)
      lb=iv(i1,6)
      boa=bo(la)-cutof2
      bob=bo(lb)-cutof2
      if (boa.lt.zero.or.bob.lt.zero) goto 10

      hl=h(i1)     ! Calculated earlier in routine calval
********************************************************************** 
*                                                                    *
*     Calculate valency angle energy                                 *
*                                                                    *
********************************************************************** 
      nbocen=ia(j(2),2)
      sbo2=0.0d00
      vmbo=1.0d00
     
      do i2=1,nbocen
      ibv=nubon2(j(2),i2)
      vmbo=vmbo*exp(-bo(ibv)**8)
      sbo2=sbo2+bopi(ibv)+bopi2(ibv)
      end do

      ity2=ia(j(2),1)
*     exbo=abo(j(2))-stlp(ia(j(2),1))
      exbo=abo(j(2))-valf(ity2)
*     if (exbo.gt.zero) exbo=zero
*     expov=exp(vka8(ity)*exbo)
*     expov2=exp(-vpar(13)*exbo)
*     htov1=2.0d00+expov2
*     htov2=1.0d00+expov+expov2
*     evboadj=htov1/htov2
      evboadj=1.0d00
      expun=exp(-vkac(ity)*exbo)
      expun2=exp(vpar(15)*exbo)
      htun1=2.0d00+expun2
      htun2=1.0d00+expun+expun2
      evboadj2=vval4(ity2)-(vval4(ity2)-1.0d00)*htun1/htun2
********************************************************************** 
*                                                                    *
*     Calculate number of lone pairs                                 *
*                                                                    *
********************************************************************** 
      dsbo2dvlp=(1.0d00-vmbo)
      vlpadj=zero
      exlp1=abo(j(2))-stlp(ia(j(2),1))
      exlp2=2.0d00*int(exlp1/2.0d00)
      exlp=exlp1-exlp2
      if (exlp.lt.zero) then
*     expvlp=exp(-vpar(16)*(2.0d00+exlp)*(2.0d00+exlp))
*     vlpadj=expvlp-int(exlp1/2.0d00)
*     dsbo2dvlp=(1.0d00-vmbo)*(1.0d00-vpar(34)*
*    $2.0d00*(2.0d00+exlp)*vpar(16)*expvlp)
      vlpadj=vlp(j(2))
      dsbo2dvlp=(1.0d00-vmbo)*(1.0d00+vpar(34)*dvlpdsbo(j(2)))
      end if

      sbo2=sbo2+(1.0d00-vmbo)*(-exbo-vpar(34)*vlpadj)
      dsbo2dvmbo=exbo+vpar(34)*vlpadj

      sbo2h=sbo2
      powv=vpar(17)
      if (sbo2.le.0.0d00) sbo2h=0.0d00
      if (sbo2.gt.0.0d00.and.sbo2.le.1.0d00) sbo2h=sbo2**powv
      if (sbo2.gt.1.0d00.and.sbo2.lt.2.0d00) 
     $ sbo2h=2.0d00-(2.0d00-sbo2)**powv
      if (sbo2.gt.2.0d00) sbo2h=2.0d00
      thba=th0(ity)
      expsbo=exp(-vpar(18)*(2.0d00-sbo2h))
      thetao=180.0d00-thba*(1.0d00-expsbo)

      thetao=thetao*dgrrdn
      thdif=(thetao-hl)
      thdi2=thdif*thdif
      dthsbo=dgrrdn*thba*vpar(18)*expsbo
      if (sbo2.lt.0.0d00) dthsbo=zero
      if (sbo2.gt.0.0d00.and.sbo2.le.1.0d00) 
     $dthsbo=powv*(sbo2**(powv-1.0d00))*dgrrdn*thba*vpar(18)*expsbo
      if (sbo2.gt.1.0d00.and.sbo2.lt.2.0d00) 
     $dthsbo=powv*((2.0d00-sbo2)**(powv-1.0d00))*dgrrdn
     $       *thba*vpar(18)*expsbo
      if (sbo2.gt.2.0d00) dthsbo=zero

      exphu=vka(ity)*exp(-vka3(ity)*thdi2)
      exphu2=vka(ity)-exphu
*     if (vka(ity).lt.zero) exphu2=exphu2-vka(ity)             !To avoid linear Me-H-Me angles (6/6/06)
      if (vka(ity).lt.zero) goto 10                            !To avoid conflicts using recent Na/H and Al/H potentials (14/2/08)
      boap=boa**vval2(ity)
      boap2=boa**(vval2(ity)-1.0d00)
      bobp=bob**vval2(ity)
      bobp2=bob**(vval2(ity)-1.0d00)
      exa=exp(-vval1(ity2)*boap)
      exb=exp(-vval1(ity2)*bobp)
      dexadboa=vval2(ity)*vval1(ity2)*exa*boap2
      dexbdbob=vval2(ity)*vval1(ity2)*exb*bobp2
      exa2=(1.0d00-exa)
      exb2=(1.0d00-exb)

      evh=evboadj2*evboadj*exa2*exb2*exphu2
CSN   if (ioutta.eq.1) write(67,'(3i6,4f12.4)')j(1),j(2),j(3),
CSN  $hl*rdndgr,thetao*rdndgr,evh,ev+epen+evh
      if (ioutta.eq.1) write(367,'(3i6,4f12.4)')j(1),j(2),j(3),
     $hl*rdndgr,thetao*rdndgr,evh,ev+epen+evh
      estrain(j(2))=estrain(j(2))+evh

      devdlb=evboadj2*evboadj*dexbdbob*exa2*exphu2
      devdla=evboadj2*evboadj*dexadboa*exb2*exphu2
      devdsbo=2.0d00*evboadj2*evboadj*dthsbo*exa2*exb2*
     $vka3(ity)*thdif*exphu
      devdh=-2.0d00*evboadj2*evboadj*exa2*exb2*vka3(ity)*thdif*exphu

      devdsbo2=
     $evboadj*exa2*exb2*exphu2*(vval4(ity2)
     $-1.0d00)*(-vpar(15)*expun2/htun2
     $+htun1*(vpar(15)*expun2-vkac(ity)*expun)/(htun2*htun2))

*     devdsbo2=-evboadj2*exa2*exb2*exphu2*(vpar(13)*expov2/htov2+
*    $htov1*(vka8(ity)*expov-vpar(13)*expov2)/(htov2*htov2))+
*    $evboadj*exa2*exb2*exphu2*(vpar(14)-1.0)*(-vpar(15)*expun2/htun2
*    $+htun1*(vpar(15)*expun2-vkac(ity)*expun)/(htun2*htun2))



      ev=ev+evh
*     write (64,'(4i8,18f8.2)')mdstep,j(1),j(2),j(3),sbo2,sbo2h,
*    $thetao*rdndgr,hl*rdndgr,bo(la),bo(lb),bopi(la),
*    $vlp(j(2)),exbo,vlpadj,vmbo,evh,ev,vka(ity)
********************************************************************** 
*                                                                    *
*     Calculate penalty for two double bonds in valency angle        *
*                                                                    *
********************************************************************** 
      exbo=abo(j(2))-aval(ia(j(2),1))
      expov=exp(vpar(22)*exbo)
      expov2=exp(-vpar(21)*exbo)
      htov1=2.0d00+expov2
      htov2=1.0d00+expov+expov2
      ecsboadj=htov1/htov2
      exphu1=exp(-vpar(20)*(boa-2.0d00)*(boa-2.0d00))
      exphu2=exp(-vpar(20)*(bob-2.0d00)*(bob-2.0d00))

      epenh=vkap(ity)*ecsboadj*exphu1*exphu2
CSN   if (ioutta.eq.1) write(68,'(3i6,4f12.4)')j(1),j(2),j(3),
CSN  $boa,bob,epenh,ev+epen+epenh
      if (ioutta.eq.1) write(368,'(3i6,4f12.4)')j(1),j(2),j(3),
     $boa,bob,epenh,ev+epen+epenh
      estrain(j(2))=estrain(j(2))+epenh

      epen=epen+epenh
      decoadboa=-2.0d00*vpar(20)*epenh*(boa-2.0d00)
      decoadbob=-2.0d00*vpar(20)*epenh*(bob-2.0d00)
      decdsbo2=-vkap(ity)*exphu1*exphu2*(vpar(21)*expov2/htov2+htov1*
     $(vpar(22)*expov-vpar(21)*expov2)/(htov2*htov2))

*     write (65,'(4i3,20f12.4)')mdstep,j(1),j(2),j(3),exbo,expov,
*    $expov2,htov1,htov2,ecsboadj,exphu1,exphu2,epenh,decoadboa,
*    $dcoadbob,decdsbo2
**********************************************************************
*                                                                    *
*     Calculate valency angle conjugation energy                     *
*                                                                    *
**********************************************************************
      unda=abo(j(1))-boa
*     ovb=abo(j(2))-valf(ia(j(2),1))
      ovb=abo(j(2))-vval3(ia(j(2),1))    !Modification for Ru  7/6/2004
      undc=abo(j(3))-bob
      ba=(boa-1.50d00)*(boa-1.50d00)
      bb=(bob-1.50d00)*(bob-1.50d00)
      exphua=exp(-vpar(31)*ba)
      exphub=exp(-vpar(31)*bb)
      exphuua=exp(-vpar(39)*unda*unda)
      exphuob=exp(vpar(3)*ovb)
      exphuuc=exp(-vpar(39)*undc*undc)
      hulpob=1.0d00/(1.0d00+exphuob)

      ecoah=vka8(ity)*exphua*exphub*exphuua*exphuuc*hulpob
CSN   if (ioutta.eq.1) write (69,'(3i6,4f12.4)')j(1),j(2),j(3),
CSN  $boa,bob,ecoah,ecoa+ecoah
      if (ioutta.eq.1) write (369,'(3i6,4f12.4)')j(1),j(2),j(3),
     $boa,bob,ecoah,ecoa+ecoah
      estrain(j(2))=estrain(j(2))+ecoah

      decodbola=-2.0d00*vka8(ity)*(boa-1.50d00)
     $*vpar(31)*exphua*exphub
     $*exphuua*exphuuc*hulpob+vpar(39)*vka8(ity)*exphua*exphub*
     $exphuua*exphuuc*hulpob*2.0d00*unda
      decodbolb=-2.0d00*vka8(ity)*(bob-1.50d00)*vpar(31)*exphua*exphub
     $*exphuua*exphuuc*hulpob+vpar(39)*vka8(ity)*exphua*exphub*
     $exphuua*exphuuc*hulpob*2.0d00*undc
      decodboua=-2.0d00*unda*vka8(ity)*vpar(39)*exphua*exphub
     $*exphuua*exphuuc*hulpob
      decodbouc=-2.0d00*undc*vka8(ity)*vpar(39)*exphua*exphub
     $*exphuua*exphuuc*hulpob
      decodboob=-vka8(ity)*exphua*exphub*exphuua*exphuuc*hulpob*
     $hulpob*vpar(3)*exphuob
      ecoa=ecoa+ecoah
*     write (64,'(4i3,20f12.4)')mdstep,j(1),j(2),j(3),vka8(ity),
*    $ba,bb,ovb,exphua,exphub,exphuua,exphuob,exphuuc,hulpob,ecoah
********************************************************************** 
*                                                                    *
*     Calculate derivative valency energy to cartesian coordinates   *
*                                                                    *
********************************************************************** 
      if (icpres.eq.0) then

      do k1=1,3
      do k2=1,3
      d(k1,j(k2))=d(k1,j(k2))+devdh*dhdc(i1,k1,k2)
      end do
      end do
 
      do i2=1,idbo1(la)
      ihu=idbo(la,i2)
      do k1=1,3
      d(k1,ihu)=d(k1,ihu)+(devdla+decoadboa+decodbola)*
     $dbondc(la,k1,i2)
      end do
      end do
 
      do i2=1,idbo1(lb)
      ihu=idbo(lb,i2)
      do k1=1,3
      d(k1,ihu)=d(k1,ihu)+(devdlb+decoadbob+decodbolb)*
     $dbondc(lb,k1,i2)
      end do
      end do
 
      do i2=1,nbocen
      j5=ia(j(2),2+i2)
      ibv=nubon2(j(2),i2)
      dvmbodbo=-vmbo*8.0d00*bo(ibv)**7
      do i3=1,idbo1(ibv)
      ihu=idbo(ibv,i3)
      do k1=1,3
      d(k1,ihu)=d(k1,ihu)+(-dsbo2dvlp*devdsbo+devdsbo2+decdsbo2
     $+dvmbodbo*dsbo2dvmbo*devdsbo)*
     $dbondc(ibv,k1,i3)+devdsbo*(dbopindc(ibv,k1,i3)+
     $dbopi2ndc(ibv,k1,i3))
      end do
      end do
      end do
 
      do i2=1,ia(j(1),2)
      j5=ia(j(1),2+i2)
      ibv=nubon2(j(1),i2)
      do i3=1,idbo1(ibv)
      ihu=idbo(ibv,i3)
      do k1=1,3
      d(k1,ihu)=d(k1,ihu)+decodboua*dbondc(ibv,k1,i3)
      end do
      end do
      end do
 
      do i2=1,ia(j(2),2)
      j5=ia(j(2),2+i2)
      ibv=nubon2(j(2),i2)
      do i3=1,idbo1(ibv)
      ihu=idbo(ibv,i3)
      do k1=1,3
      d(k1,ihu)=d(k1,ihu)+decodboob*dbondc(ibv,k1,i3)
      end do
      end do
      end do

      do i2=1,ia(j(3),2)
      j5=ia(j(3),2+i2)
      ibv=nubon2(j(3),i2)
      do i3=1,idbo1(ibv)
      ihu=idbo(ibv,i3)
      do k1=1,3
      d(k1,ihu)=d(k1,ihu)+decodbouc*dbondc(ibv,k1,i3)
      end do
      end do
      end do

      else

      do k1=1,3
      do k2=1,3
      ix=nmpx(j(2),j(k2))
      iy=nmpy(j(2),j(k2))
      iz=nmpz(j(2),j(k2))
      kcell=14+ix+3*iy+9*iz
      dcell(k1,j(k2),kcell)=dcell(k1,j(k2),kcell)+devdh*dhdc(i1,k1,k2)
      end do
      end do

      do i2=1,idbo1(la)
      ihu=idbo(la,i2)
      ix=nmpx(j(2),ihu)
      iy=nmpy(j(2),ihu)
      iz=nmpz(j(2),ihu)
      kcell=14+ix+3*iy+9*iz
      do k1=1,3
      dcell(k1,ihu,kcell)=dcell(k1,ihu,kcell)+
     $(devdla+decoadboa+decodbola)*dbondc(la,k1,i2)
      end do
      end do

      do i2=1,idbo1(lb)
      ihu=idbo(lb,i2)
      ix=nmpx(j(2),ihu)
      iy=nmpy(j(2),ihu)
      iz=nmpz(j(2),ihu)
      kcell=14+ix+3*iy+9*iz
      do k1=1,3
      dcell(k1,ihu,kcell)=dcell(k1,ihu,kcell)+
     $(devdlb+decoadbob+decodbolb)*dbondc(lb,k1,i2)
      end do
      end do

      do i2=1,nbocen
      j5=ia(j(2),2+i2)
      ibv=nubon2(j(2),i2)
      dvmbodbo=-vmbo*8.0d00*bo(ibv)**7
      do i3=1,idbo1(ibv)
      ihu=idbo(ibv,i3)
      ix=nmpx(j(2),ihu)
      iy=nmpy(j(2),ihu)
      iz=nmpz(j(2),ihu)
      kcell=14+ix+3*iy+9*iz
      do k1=1,3
      dcell(k1,ihu,kcell)=dcell(k1,ihu,kcell)+
     $(-dsbo2dvlp*devdsbo+devdsbo2+decdsbo2+
     $dvmbodbo*dsbo2dvmbo*devdsbo)*
     $dbondc(ibv,k1,i3)+devdsbo*(dbopindc(ibv,k1,i3)+
     $dbopi2ndc(ibv,k1,i3))
      end do
      end do
      end do

      do i2=1,ia(j(1),2)
      j5=ia(j(1),2+i2)
      ibv=nubon2(j(1),i2)
      do i3=1,idbo1(ibv)
      ihu=idbo(ibv,i3)
      ix=nmpx(j(2),ihu)
      iy=nmpy(j(2),ihu)
      iz=nmpz(j(2),ihu)
      kcell=14+ix+3*iy+9*iz
      do k1=1,3
      dcell(k1,ihu,kcell)=dcell(k1,ihu,kcell)+
     $decodboua*dbondc(ibv,k1,i3)
      end do
      end do
      end do

      do i2=1,ia(j(2),2)
      j5=ia(j(2),2+i2)
      ibv=nubon2(j(2),i2)
      do i3=1,idbo1(ibv)
      ihu=idbo(ibv,i3)
      ix=nmpx(j(2),ihu)
      iy=nmpy(j(2),ihu)
      iz=nmpz(j(2),ihu)
      kcell=14+ix+3*iy+9*iz
      do k1=1,3
      dcell(k1,ihu,kcell)=dcell(k1,ihu,kcell)+
     $decodboob*dbondc(ibv,k1,i3)
      end do
      end do
      end do

      do i2=1,ia(j(3),2)
      j5=ia(j(3),2+i2)
      ibv=nubon2(j(3),i2)
      do i3=1,idbo1(ibv)
      ihu=idbo(ibv,i3)
      ix=nmpx(j(2),ihu)
      iy=nmpy(j(2),ihu)
      iz=nmpz(j(2),ihu)
      kcell=14+ix+3*iy+9*iz
      do k1=1,3
      dcell(k1,ihu,kcell)=dcell(k1,ihu,kcell)+
     $decodbouc*dbondc(ibv,k1,i3)
      end do
      end do
      end do

      end if

   10 continue
      if (ioutta.eq.1) then
CSN   close(67)
CSN   close(68)
CSN   close(69)

      CALL SEQCLO(367,'KEEP')
      CALL SEQCLO(368,'KEEP')
      CALL SEQCLO(369,'KEEP')

      end if

      return
  100 format ('  Atom1 Atom2 Atom3    Angle     Angle(0) ',
     $'      Eangle sum(Eangle+Epen)')
  200 format ('  Atom1 Atom2 Atom3      BO12        BO13       Epen  '
     $,'  sum(Epen+Eangle)')
  300 format ('  Atom1 Atom2 Atom3      BO12        BO13      E13conj'
     $,'   sum(E13conj)')
      end
**********************************************************************
********************************************************************** 

C*MODULE POTEN    *DECK HBOND
C> @brief    hydrogen bond energies and gradients
C>
C> @details  calculate hydrogen bond energies and first derivatives 
C>
C> @author   Sean Nedd (implementation), Adri van Duin (original author), 2010-2012
C>
C> @date 11-11-14 - Sean A. Nedd
C>
      subroutine hbond

********************************************************************** 
      include 'cbka.blk'
      dimension drda(3),j(3),dvdc(3,3),dargdc(3,3)
      virial=zero
      virx=zero
      viry=zero
      virz=zero
********************************************************************** 
*                                                                    *
*     Calculate hydrogen bond energies and first derivatives         *
*                                                                    *
********************************************************************** 
      if (ndebug.eq.1) then
CSN   open (65,file='/u1/sean/gamessnew/ffparams/fort.65',
CSN  *      status='unknown',access='append')
CSN   write (65,*) 'In hbond'
CSN   call timer(65)
CSN   close (65)

      CALL SEQOPN(365,'FORT65','UNKNOWN',.FALSE.,'FORMATTED')
      write (365,*) 'In hbond'
      call timer(365)
      CALL SEQCLO(365,'KEEP')

      end if

      if (ioutta.eq.1) then
CSN   open (67,file='/u1/sean/gamessnew/ffparams/hbond.dat',
CSN  *      status='unknown',access='append')
CSN   write (67,100)
CSN   write (6,100)

      CALL SEQOPN(367,'FORT-67','UNKNOWN',.FALSE.,'FORMATTED')
      write (67,100)

      end if

      ehb=zero
      do 10 i1=1,nhb
      ityhb=ihb(i1,1)
      j(1)=ihb(i1,2)
      j(2)=ihb(i1,3)
      j(3)=ihb(i1,4)
      la=ihb(i1,5)
      ix=ihb(i1,6)
      iy=ihb(i1,7)
      iz=ihb(i1,8)
      dxm=c(j(2),1)-c(j(3),1)+ix*tm11
      dym=c(j(2),2)-c(j(3),2)+ix*tm21+iy*tm22
      dzm=c(j(2),3)-c(j(3),3)+ix*tm31+iy*tm32+iz*tm33
      boa=bo(la)
      rda=sqrt(dxm*dxm+dym*dym+dzm*dzm)
      drda(1)=dxm/rda
      drda(2)=dym/rda
      drda(3)=dzm/rda
      call calvalhb(j(1),j(2),j(3),ix,iy,iz,arg,hhb(i1),dvdc,dargdc)
      rhu1=rhb(ityhb)/rda
      rhu2=rda/rhb(ityhb)
      sinhu=sin(hhb(i1)/2.0d00)
      sin2=sinhu*sinhu
      exphu1=exp(-vhb1(ityhb)*boa)
      exphu2=exp(-vhb2(ityhb)*(rhu1+rhu2-2.0d00))

      ehbh=(1.0d00-exphu1)*dehb(ityhb)*exphu2*sin2*sin2
CSN   if (ioutta.eq.1) write(7,'(3i6,5f12.4)')j(1),j(2),j(3),rda,
CSN  $hhb(i1)*rdndgr,boa,ehbh,ehb+ehbh
CSN   if (ioutta.eq.1) write(67,'(3i6,5f12.4)')j(1),j(2),j(3),rda,
CSN  $hhb(i1)*rdndgr,boa,ehbh,ehb+ehbh
      if (ioutta.eq.1) write(367,'(3i6,5f12.4)')j(1),j(2),j(3),rda,
     $hhb(i1)*rdndgr,boa,ehbh,ehb+ehbh
*     ehbh=(1.0d00-exphu1)*dehb(ityhb)*exphu2*sin2*sin2*sin2*sin2
      estrain(j(2))=estrain(j(2))+0.50d00*ehbh
      estrain(j(3))=estrain(j(3))+0.50d00*ehbh

      ehb=ehb+ehbh
*     write (63,'(9i4,10f12.4)')i1,ityhb,j(1),j(2),j(3),ix,iy,iz,la,
*    $boa,rda,rdndgr*hhb(i1),1.0-exphu1,exphu2,sin2*sin2,
*    $ehbh,ehb
********************************************************************** 
*                                                                    *
*     Calculate first derivatives                                    *
*                                                                    *
********************************************************************** 
*     dehbdbo=vhb1(ityhb)*exphu1*dehb(ityhb)*exphu2*sin2*sin2*
*    $sin2*sin2
*     dehbdv=(1.0-exphu1)*dehb(ityhb)*exphu2*
*    $4.0*sin2*sin2*sin2*sinhu*cos(hhb(i1)/2.0)
*     dehbdrda=(1.0-exphu1)*dehb(ityhb)*sin2*sin2*sin2*sin2*
*    $vhb2(ityhb)*(rhb(ityhb)/(rda*rda)-1.0/rhb(ityhb))*exphu2
      dehbdbo=vhb1(ityhb)*exphu1*dehb(ityhb)*exphu2*sin2*sin2
      dehbdv=(1.0d00-exphu1)*dehb(ityhb)*exphu2*
     $2.0d00*sin2*sinhu*cos(hhb(i1)/2.0d00)
      dehbdrda=(1.0d00-exphu1)*dehb(ityhb)*sin2*sin2*
     $vhb2(ityhb)*(rhb(ityhb)/(rda*rda)-1.0d00/rhb(ityhb))*exphu2

      if (icpres.eq.0) then

      do k1=1,3
      d(k1,j(2))=d(k1,j(2))+dehbdrda*drda(k1)
      d(k1,j(3))=d(k1,j(3))-dehbdrda*drda(k1)
      end do
 
      do k1=1,3
      do k2=1,3
      d(k1,j(k2))=d(k1,j(k2))+dehbdv*dvdc(k1,k2)
      end do
      end do
 
      do i2=1,idbo1(la)
      ihu=idbo(la,i2)
      do k1=1,3
      d(k1,ihu)=d(k1,ihu)+dehbdbo*dbondc(la,k1,i2)
      end do
      end do

      else

      ix=nmpx(j(2),j(3))
      iy=nmpy(j(2),j(3))
      iz=nmpz(j(2),j(3))
      kcell=14+ix+3*iy+9*iz
      do k1=1,3
      dcell(k1,j(2),kcell)=dcell(k1,j(2),kcell)+dehbdrda*drda(k1)
      dcell(k1,j(3),kcell)=dcell(k1,j(3),kcell)-dehbdrda*drda(k1)
      end do
     
      do k1=1,3
      do k2=1,3
      ix=nmpx(j(2),j(k2))
      iy=nmpy(j(2),j(k2))
      iz=nmpz(j(2),j(k2))
      kcell=14+ix+3*iy+9*iz
      dcell(k1,j(k2),kcell)=dcell(k1,j(k2),kcell)+dehbdv*dvdc(k1,k2)
      end do
      end do
  
      do i2=1,idbo1(la)
      ihu=idbo(la,i2)
      ix=nmpx(j(2),ihu)
      iy=nmpy(j(2),ihu)
      iz=nmpz(j(2),ihu)
      kcell=14+ix+3*iy+9*iz
      do k1=1,3
      dcell(k1,ihu,kcell)=dcell(k1,ihu,kcell)+
     $dehbdbo*dbondc(la,k1,i2)
      end do
      end do

      end if

   
   10 continue
c     return
      if (ioutta.eq.1) then
CSN   close(67)

      CALL SEQCLO(367,'KEEP')

      end if

      return
  100 format ('  Atom1 Atom2 Atom3      r(23)      Angle       BO(12)'
     $,'       Ehb       sum(Ehb)')
      end 

********************************************************************** 
********************************************************************** 

C*MODULE POTEN    *DECK TORANG
C> @brief    torsion angle energies and gradients
C>
C> @details  calculate torsion angle energies and first derivatives
C> 
C> @author   Sean Nedd (implementation), Adri van Duin (original author), 2010-2012
C>
C> @date 11-11-14 - Sean A. Nedd
C>
      subroutine torang

********************************************************************** 
      include 'cbka.blk'
      DIMENSION  A(3),DRDA(3),DADC(4),DRADC(3,4),DRBDC(3,4),
     $DRCDC(3,4),DHDDC(3,4),DHEDC(3,4),DRVDC(3,4),DTDC(3,4),
     $DNDC(3,4)
      dimension j(4),dh1rdc(3,3),dh2rdc(3,3),dargdc(3,3)
********************************************************************** 
*                                                                    *
*     Calculate torsion angle energies and first derivatives         *
*                                                                    *
********************************************************************** 
      if (ndebug.eq.1) then
CSN   open (65,file='/u1/sean/gamessnew/ffparams/fort.65',
CSN  *      status='unknown',access='append')
CSN   write (65,*) 'In torang'
CSN   call timer(65)
CSN   close (65)

      CALL SEQOPN(365,'FORT65','UNKNOWN',.FALSE.,'FORMATTED')
      write (365,*) 'In torang'
      call timer(365)
      CALL SEQCLO(365,'KEEP')

      end if

      if (ioutta.eq.1) then
CSN   open (67,file='/u1/sean/gamessnew/ffparams/torsion.dat',
CSN  *      status='unknown',access='append')
CSN   write (6,100)
CSN   write (67,100)

      CALL SEQOPN(365,'FORT=67','UNKNOWN',.FALSE.,'FORMATTED')
      write (367,100)

CSN   open (68,file='/u1/sean/gamessnew/ffparams/conjugation.dat',
CSN  *      status='unknown',access='append')
CSN   write (6,200)
CSN   write (68,200)

      CALL SEQOPN(368,'FORT-68,'UNKNOWN',.FALSE.,'FORMATTED')
      write (368,200)

      end if

      do k1=1,3
      do k2=1,4
      dhddc(k1,k2)=0.0d00
      dhedc(k1,k2)=0.0d00
      dradc(k1,k2)=0.0d00
      drbdc(k1,k2)=0.0d00
      drcdc(k1,k2)=0.0d00
      end do
      end do
      et=0.0d00
      eth12=0.0d00
      eco=0.0d00
      dadc(1)=1.0d00
      dadc(2)=0.0d00
      dadc(3)=0.0d00
      dadc(4)=-1.0d00
      if (ntor.eq.0) return

      do 10 i1=1,ntor
      j(1)=it(i1,2)
      j(2)=it(i1,3)
      j(3)=it(i1,4)
      j(4)=it(i1,5)
      ity=it(i1,1)  
      la=it(i1,6)
      lb=it(i1,7)
      lc=it(i1,8)
      call calvalres(j(1),j(2),j(3),arg1,ht1,dh1rdc,dargdc)
      call calvalres(j(2),j(3),j(4),arg2,ht2,dh2rdc,dargdc)
      boa=bo(la)-cutof2
      bob=bo(lb)-cutof2
      boc=bo(lc)-cutof2
      if (boa.lt.zero.or.bob.lt.zero.or.boc.lt.zero) 
     $goto 10
      r42=0.0d00
      ivl1=ibsym(la)
      ivl2=ibsym(lb)
      ivl3=ibsym(lc)
      isign1=1
      isign2=1
      isign3=1
      if (j(2).lt.j(1)) isign1=-1
      if (j(3).lt.j(2)) isign2=-1
      if (j(4).lt.j(3)) isign3=-1
      rla=rbo(la)
      rlb=rbo(lb)
      ix1=isign1*nvlx(ivl1)+isign2*nvlx(ivl2)+isign3*nvlx(ivl3)
      iy1=isign1*nvly(ivl1)+isign2*nvly(ivl2)+isign3*nvly(ivl3)
      iz1=isign1*nvlz(ivl1)+isign2*nvlz(ivl2)+isign3*nvlz(ivl3)
 
      a(1)=c(j(1),1)-c(j(4),1)+ix1*tm11
      a(2)=c(j(1),2)-c(j(4),2)+ix1*tm21+iy1*tm22
      a(3)=c(j(1),3)-c(j(4),3)+ix1*tm31+iy1*tm32+iz1*tm33
      r4=sqrt(a(1)*a(1)+a(2)*a(2)+a(3)*a(3))
********************************************************************** 
*                                                                    *
*     Determine torsion angle                                        *
*                                                                    *
********************************************************************** 
      d142=r4*r4
      rla=rbo(la)
      rlb=rbo(lb)
      rlc=rbo(lc)
      coshd=cos(ht1)
      coshe=cos(ht2)
      sinhd=sin(ht1)
      sinhe=sin(ht2)
      poem=2.0d00*rla*rlc*sinhd*sinhe
      poem2=poem*poem
      tel=rla*rla+rlb*rlb+rlc*rlc-d142-2.0d00*(rla*rlb*coshd-rla*rlc*
     $coshd*coshe+rlb*rlc*coshe)
      if (poem.lt.1d-20) poem=1d-20
      arg=tel/poem
      if (arg.gt.1.0d00) arg=1.0d00
      if (arg.lt.-1.0d00) arg=-1.0d00
      arg2=arg*arg
      thg(i1)=acos(arg)*rdndgr
      k1=j(1)
      k2=j(2)
      k3=j(3)
      k4=j(4)
      call dista2(k3,k2,dis,x3,y3,z3)
      y32z32=y3*y3+z3*z3
      wort1=sqrt(y32z32)+1d-6
      wort2=sqrt(y32z32+x3*x3)+1d-6
*     if (wort1.lt.1d-6) wort1=1d-6
*     if (wort2.lt.1d-6) wort2=1d-6
      sinalf=y3/wort1
      cosalf=z3/wort1
      sinbet=x3/wort2
      cosbet=wort1/wort2
      call dista2(k1,k2,dis,x1,y1,z1)
      x1=x1*cosbet-y1*sinalf*sinbet-z1*cosalf*sinbet
      y1=y1*cosalf-z1*sinalf
      wort3=sqrt(x1*x1+y1*y1)+1d-6
*     if (wort3.lt.1d-6) wort3=1d-6
      singam=y1/wort3
      cosgam=x1/wort3
      call dista2(k4,k2,dis,x4,y4,z4)
      x4=x4*cosbet-y4*sinalf*sinbet-z4*cosalf*sinbet
      y4=y4*cosalf-z4*sinalf
      y4=x4*singam-y4*cosgam
      if (y4.gt.0.0d00) thg(i1)=-thg(i1)
      if (thg(i1).lt.-179.999999d0) thg(i1)=-179.999999d0
      if (thg(i1).gt.179.999999d0) thg(i1)=179.999999d0
      th2=thg(i1)*dgrrdn
********************************************************************** 
*                                                                    *
*     Calculate torsion angle energy                                 *
*                                                                    *
********************************************************************** 
      exbo1=abo(j(2))-valf(ia(j(2),1))
      exbo2=abo(j(3))-valf(ia(j(3),1))
      htovt=exbo1+exbo2
      expov=exp(vpar(26)*htovt)
      expov2=exp(-vpar(25)*htovt)
      htov1=2.0d00+expov2
      htov2=1.0d00+expov+expov2
      etboadj=htov1/htov2

*     btb2=bopi(lb)-1.0d00+etboadj
*     bo2t=1.0d00-btb2
      bo2t=2.0d00-bopi(lb)-etboadj
      bo2p=bo2t*bo2t
      bocor2=exp(v4(ity)*bo2p)

      hsin=sinhd*sinhe
      ethhulp=0.50d00*v1(ity)*(1.0d00+arg)+
     $v2(ity)*bocor2*(1.0d00-arg2)+
     $v3(ity)*(0.50d00+2.0d00*arg2*arg-1.50d00*arg)

      exphua=exp(-vpar(24)*boa)
      exphub=exp(-vpar(24)*bob)
      exphuc=exp(-vpar(24)*boc)
      bocor4=(1.0d00-exphua)*(1.0d00-exphub)*(1.0d00-exphuc)

      eth=hsin*ethhulp*bocor4
CSN   if (ioutta.eq.1) write (7,'(4i6,4f12.4)')j(1),j(2),j(3),j(4),
CSN  $thg(i1),bob,eth,et+eth
CSN   if (ioutta.eq.1) write (67,'(4i6,4f12.4)')j(1),j(2),j(3),j(4),
CSN  $thg(i1),bob,eth,et+eth
      if (ioutta.eq.1) write (367,'(4i6,4f12.4)')j(1),j(2),j(3),j(4),
     $thg(i1),bob,eth,et+eth
      estrain(j(2))=estrain(j(2))+0.50d00*eth
      estrain(j(3))=estrain(j(3))+0.50d00*eth

      detdar=hsin*bocor4*(0.50d00*v1(ity)-2.0d00*v2(ity)*bocor2*arg+
     $v3(ity)*(6.0d00*arg2-1.5d0))
      detdhd=coshd*sinhe*bocor4*ethhulp
      detdhe=sinhd*coshe*bocor4*ethhulp

      detdboa=vpar(24)*exphua*(1.0d00-exphub)*
     $(1.0d00-exphuc)*ethhulp*hsin
      detdbopib=-bocor4*2.0d00*v4(ity)*v2(ity)*
     $bo2t*bocor2*(1.0d00-arg2)*hsin
      detdbob=vpar(24)*exphub*(1.0d00-exphua)*
     $(1.0d00-exphuc)*ethhulp*hsin
      detdboc=vpar(24)*exphuc*(1.0d00-exphua)*
     $(1.0d00-exphub)*ethhulp*hsin

      detdsbo1=-detdbopib*
     $(vpar(25)*expov2/htov2+htov1*
     $(vpar(26)*expov-vpar(25)*expov2)/(htov2*htov2))

      et=et+eth
********************************************************************** 
*                                                                    *
*     Calculate conjugation energy                                   *
*                                                                    *
********************************************************************** 
      ba=(boa-1.50d00)*(boa-1.50d00)
      bb=(bob-1.50d00)*(bob-1.50d00)
      bc=(boc-1.50d00)*(boc-1.50d00)
      exphua1=exp(-vpar(28)*ba)
      exphub1=exp(-vpar(28)*bb)
      exphuc1=exp(-vpar(28)*bc)
      sbo=exphua1*exphub1*exphuc1
      dbohua=-2.0d00*(boa-1.50d00)*vpar(28)*exphua1*exphub1*exphuc1
      dbohub=-2.0d00*(bob-1.50d00)*vpar(28)*exphua1*exphub1*exphuc1
      dbohuc=-2.0d00*(boc-1.50d00)*vpar(28)*exphua1*exphub1*exphuc1
      arghu0=(arg2-1.0d00)*sinhd*sinhe
      ehulp=vconj(ity)*(arghu0+1.0d00)

      ecoh=ehulp*sbo
CSN   if (ioutta.eq.1) write (68,'(4i6,6f12.4)')j(1),j(2),j(3),j(4),
CSN  $thg(i1),boa,bob,boc,ecoh,eco+ecoh
      if (ioutta.eq.1) write (368,'(4i6,6f12.4)')j(1),j(2),j(3),j(4),
     $thg(i1),boa,bob,boc,ecoh,eco+ecoh
      estrain(j(2))=estrain(j(2))+0.50d00*ecoh
      estrain(j(3))=estrain(j(3))+0.50d00*ecoh

      decodar=sbo*vconj(ity)*2.0d00*arg*sinhd*sinhe
      decodbola=dbohua*ehulp
      decodbolb=dbohub*ehulp
      decodbolc=dbohuc*ehulp
      decodhd=coshd*sinhe*vconj(ity)*sbo*(arg2-1.0d00)
      decodhe=coshe*sinhd*vconj(ity)*sbo*(arg2-1.0d00)
      eco=eco+ecoh
    1 continue
********************************************************************** 
*                                                                    *
*     Calculate derivative torsion angle and conjugation energy      *
*     to cartesian coordinates                                       *
*                                                                    *
********************************************************************** 
      SINTH=SIN(THG(i1)*DGRRDN)
      IF (SINTH.GE.0.0d00.AND.SINTH.LT.1.0D-10) SINTH=1.0D-10
      IF (SINTH.LT.0.0d00.AND.SINTH.GT.-1.0D-10) SINTH=-1.0D-10
      IF (j(1).EQ.IB(LA,2)) THEN
      DO  K1=1,3
      DRADC(K1,1)=DRDC(LA,K1,1)
      DRADC(K1,2)=DRDC(LA,K1,2)
      end do
      ELSE
      DO  K1=1,3
      DRADC(K1,1)=DRDC(LA,K1,2)
      DRADC(K1,2)=DRDC(LA,K1,1)
      end do
      ENDIF
      IF (j(2).EQ.IB(LB,2)) THEN
      DO  K1=1,3
      DRBDC(K1,2)=DRDC(LB,K1,1)
      DRBDC(K1,3)=DRDC(LB,K1,2)
      end do
      ELSE
      DO K1=1,3
      DRBDC(K1,2)=DRDC(LB,K1,2)
      DRBDC(K1,3)=DRDC(LB,K1,1)
      end do
      ENDIF
      IF (j(3).EQ.IB(LC,2)) THEN
      DO K1=1,3
      DRCDC(K1,3)=DRDC(LC,K1,1)
      DRCDC(K1,4)=DRDC(LC,K1,2)
      end do
      ELSE
      DO K1=1,3
      DRCDC(K1,3)=DRDC(LC,K1,2)
      DRCDC(K1,4)=DRDC(LC,K1,1)
      end do
      ENDIF

      do k1=1,3
      dhddc(1,k1)=dh1rdc(1,k1)
      dhddc(2,k1)=dh1rdc(2,k1)
      dhddc(3,k1)=dh1rdc(3,k1)
      dhedc(1,k1+1)=dh2rdc(1,k1)
      dhedc(2,k1+1)=dh2rdc(2,k1)
      dhedc(3,k1+1)=dh2rdc(3,k1)
      end do

********************************************************************** 
*     write (64,*)j(1),j(2),j(3),j(4)
*     do k1=1,3
*     write (64,'(10f12.4)')(dh1rdc(k1,k2),k2=1,3),
*    $(dhdc(ld,k1,k2),k2=1,3),(dhddc(k1,k2),k2=1,4)
*     write (64,'(10f12.4)')(dh2rdc(k1,k2),k2=1,3),
*    $(dhdc(le,k1,k2),k2=1,3),(dhedc(k1,k2),k2=1,4)
*     end do
*     write (64,*)
********************************************************************** 
      HTRA=RLA+COSHD*(RLC*COSHE-RLB)
      HTRB=RLB-RLA*COSHD-RLC*COSHE
      HTRC=RLC+COSHE*(RLA*COSHD-RLB)
      HTHD=RLA*SINHD*(RLB-RLC*COSHE)
      HTHE=RLC*SINHE*(RLB-RLA*COSHD)
      HNRA=RLC*SINHD*SINHE
      HNRC=RLA*SINHD*SINHE
      HNHD=RLA*RLC*COSHD*SINHE
      HNHE=RLA*RLC*SINHD*COSHE

      if (icpres.eq.0) then

      DO  K1=1,3
      DRDA(K1)=A(K1)/R4
      DO  K2=1,4
      DRVDC(K1,K2)=DRDA(K1)*DADC(K2)
      DTDC(K1,K2)=2.0d00*(DRADC(K1,K2)*
     $HTRA+DRBDC(K1,K2)*HTRB+DRCDC(K1,K2
     $)*HTRC-DRVDC(K1,K2)*R4+DHDDC(K1,K2)*HTHD+DHEDC(K1,K2)*HTHE)
      DNDC(K1,K2)=2.0d00*(DRADC(K1,K2)*
     $HNRA+DRCDC(K1,K2)*HNRC+DHDDC(K1,K2
     $)*HNHD+DHEDC(K1,K2)*HNHE)
      DARGTDC(i1,K1,K2)=(DTDC(K1,K2)-ARG*DNDC(K1,K2))/POEM
 
      D(K1,J(K2))=D(K1,J(K2))+DARGTDC(i1,K1,K2)*detdar+
     $dargtdc(i1,k1,k2)*decodar+(detdhd+decodhd)*dhddc(k1,k2)+
     $(detdhe+decodhe)*dhedc(k1,k2)
      end do
      end do
 
      do i2=1,idbo1(la)
      ihu=idbo(la,i2)
      do k1=1,3
      d(k1,ihu)=d(k1,ihu)+dbondc(la,k1,i2)*(detdboa+decodbola)
      end do
      end do
 
      do i2=1,idbo1(lb)
      ihu=idbo(lb,i2)
      do k1=1,3
      d(k1,ihu)=d(k1,ihu)+dbondc(lb,k1,i2)*(detdbob+decodbolb)
      d(k1,ihu)=d(k1,ihu)+dbopindc(lb,k1,i2)*detdbopib
      end do
      end do
 
      do i2=1,idbo1(lc)
      ihu=idbo(lc,i2)
      do k1=1,3
      d(k1,ihu)=d(k1,ihu)+dbondc(lc,k1,i2)*(detdboc+decodbolc)
      end do
      end do
 
      do i2=1,ia(j(2),2)
      iob=ia(j(2),2+i2)
      ncubo=nubon2(j(2),i2)
      do i3=1,idbo1(ncubo)
      ihu=idbo(ncubo,i3)
      do k1=1,3
      d(k1,ihu)=d(k1,ihu)+detdsbo1*dbondc(ncubo,k1,i3)
      end do
      end do
      end do

      do i2=1,ia(j(3),2)
      iob=ia(j(3),2+i2)
      ncubo=nubon2(j(3),i2)
      do i3=1,idbo1(ncubo)
      ihu=idbo(ncubo,i3)
      do k1=1,3
      d(k1,ihu)=d(k1,ihu)+detdsbo1*dbondc(ncubo,k1,i3)
      end do
      end do
      end do

      else

      DO  K1=1,3
      DRDA(K1)=A(K1)/R4
      DO  K2=1,4
      DRVDC(K1,K2)=DRDA(K1)*DADC(K2)
      DTDC(K1,K2)=2.0d00*(DRADC(K1,K2)
     $*HTRA+DRBDC(K1,K2)*HTRB+DRCDC(K1,K2
     $)*HTRC-DRVDC(K1,K2)*R4+DHDDC(K1,K2)*HTHD+DHEDC(K1,K2)*HTHE)
      DNDC(K1,K2)=2.0d00*(DRADC(K1,K2)*
     $HNRA+DRCDC(K1,K2)*HNRC+DHDDC(K1,K2
     $)*HNHD+DHEDC(K1,K2)*HNHE)
      DARGTDC(i1,K1,K2)=(DTDC(K1,K2)-ARG*DNDC(K1,K2))/POEM
      ix=nmpx(j(2),j(k2))
      iy=nmpy(j(2),j(k2))
      iz=nmpz(j(2),j(k2))
      kcell=14+ix+3*iy+9*iz
      dcell(k1,j(k2),kcell)=dcell(k1,j(k2),kcell)
     $+dargtdc(i1,K1,K2)*detdar+
     $dargtdc(i1,k1,k2)*decodar+(detdhd+decodhd)*dhddc(k1,k2)+
     $(detdhe+decodhe)*dhedc(k1,k2)
      end do
      end do

      do i2=1,idbo1(la)  
      ihu=idbo(la,i2)
      ix=nmpx(j(2),ihu)
      iy=nmpy(j(2),ihu)
      iz=nmpz(j(2),ihu)
      kcell=14+ix+3*iy+9*iz
      do k1=1,3
      dcell(k1,ihu,kcell)=dcell(k1,ihu,kcell)+
     $dbondc(la,k1,i2)*(detdboa+decodbola)
      end do
      end do

      do i2=1,idbo1(lb)  
      ihu=idbo(lb,i2)
      ix=nmpx(j(2),ihu)
      iy=nmpy(j(2),ihu)
      iz=nmpz(j(2),ihu)
      kcell=14+ix+3*iy+9*iz
      do k1=1,3
      dcell(k1,ihu,kcell)=dcell(k1,ihu,kcell)+
     $dbondc(lb,k1,i2)*(detdbob+decodbolb)
      dcell(k1,ihu,kcell)=dcell(k1,ihu,kcell)+
     $dbopindc(lb,k1,i2)*detdbopib
      end do
      end do

      do i2=1,idbo1(lc)  
      ihu=idbo(lc,i2)
      ix=nmpx(j(2),ihu)
      iy=nmpy(j(2),ihu)
      iz=nmpz(j(2),ihu)
      kcell=14+ix+3*iy+9*iz
      do k1=1,3
      dcell(k1,ihu,kcell)=dcell(k1,ihu,kcell)+
     $dbondc(lc,k1,i2)*(detdboc+decodbolc)
      end do
      end do

      do i2=1,ia(j(2),2)
      iob=ia(j(2),2+i2)
      ncubo=nubon2(j(2),i2)
      do i3=1,idbo1(ncubo)  
      ihu=idbo(ncubo,i3)
      ix=nmpx(j(2),ihu)
      iy=nmpy(j(2),ihu)
      iz=nmpz(j(2),ihu)
      kcell=14+ix+3*iy+9*iz
      do k1=1,3
      dcell(k1,ihu,kcell)=dcell(k1,ihu,kcell)+
     $detdsbo1*dbondc(ncubo,k1,i3)
      end do
      end do
      end do

      do i2=1,ia(j(3),2)
      iob=ia(j(3),2+i2)
      ncubo=nubon2(j(3),i2)
      do i3=1,idbo1(ncubo)  
      ihu=idbo(ncubo,i3)
      ix=nmpx(j(2),ihu)
      iy=nmpy(j(2),ihu)
      iz=nmpz(j(2),ihu)
      kcell=14+ix+3*iy+9*iz
      do k1=1,3
      dcell(k1,ihu,kcell)=dcell(k1,ihu,kcell)+
     $detdsbo1*dbondc(ncubo,k1,i3)
      end do
      end do
      end do

      end if

   10 continue 

      if (ioutta.eq.1) then
CSN   close(67)
CSN   close(68)

      CALL SEQCLO(367,'KEEP')
      CALL SEQCLO(368,'KEEP')

      end if
      return

  100 format ('  Atom1 Atom2 Atom3 Atom4   Dihedral      BO(23)'
     $,'       Etors     sum(Etors)')
  200 format ('  Atom1 Atom2 Atom3 Atom4   Dihedral      BO(12)    ',
     $'   BO(23)      BO(34)       Econj     sum(Econj)')
      end 
********************************************************************** 
********************************************************************** 

C*MODULE POTEN    *DECK NONBON
C> @brief    vdWaals and coulomb energies and gradients
C>
C> @details  calculate vdWaals and coulomb energies and derivatives 
C>
C> @author   Sean Nedd (implementation), Adri van Duin (original author), 2010-2012
C>
C> @date 11-11-14 - Sean A. Nedd
C>
      subroutine nonbon

********************************************************************** 
      include 'cbka.blk'
      dimension a(3),da(6)
********************************************************************** 
*                                                                    *
*     Calculate vdWaals and Coulomb energies and derivatives         *
*                                                                    *
********************************************************************** 
      if (ndebug.eq.1) then
CSN   open (65,file='/u1/sean/gamessnew/ffparams/fort.65',
CSN  *      status='unknown',access='append')
CSN   write (65,*) 'In nonbon'
CSN   call timer(65)

      CALL SEQOPN(365,'FORT65','UNKNOWN',.FALSE.,'FORMATTED')
      write (365,*) 'In nonbon'
      call timer(365)
      CALL SEQCLO(365,'KEEP')

      end if

      if (ioutta.eq.1) then
CSN   open (67,file='/u1/sean/gamessnew/ffparams/vdWaals.dat',
CSN  *      status='unknown',access='append')
CSN   write (6,100)
CSN   write (67,100)

      CALL SEQOPN(367,'FORT_67','UNKNOWN',.FALSE.,'FORMATTED')
      write (367,100)

CSN   open (68,file='/u1/sean/gamessnew/ffparams/Coulomb.dat',
CSN  *      status='unknown',access='append')
CSN   write (6,200)
CSN   write (68,200)

      CALL SEQOPN(368,'FORT=68','UNKNOWN',.FALSE.,'FORMATTED')
      write (368,200)

      fothird=4.0d00/3.0d00
      twothird=2.0d00/3.0d00
      h15=(vpar(29)-1.0d00)/vpar(29)

      do 10 ivl=1,nvpair-nvlself
      i1=nvl1(ivl)
      i2=nvl2(ivl)
      ix=nvlx(ivl)
      iy=nvly(ivl)
      iz=nvlz(ivl)
      a(1)=c(i1,1)-c(i2,1)+ix*tm11
      a(2)=c(i1,2)-c(i2,2)+ix*tm21+iy*tm22
      a(3)=c(i1,3)-c(i2,3)+ix*tm31+iy*tm32+iz*tm33
**********************************************************************
*                                                                    *
*     Construct periodic images for each interaction                 *
*                                                                    *
**********************************************************************
      rr=sqrt(a(1)*a(1)+a(2)*a(2)+a(3)*a(3))
      if (rr.gt.swb.or.rr.lt.0.001d00) goto 10
      ity1=ia(i1,1)
      ity2=ia(i2,1)
      imol1=iag(i1,3+mbond)
      imol2=iag(i2,3+mbond)
      rr2=rr*rr

      sw=1.0d00
      sw1=0.0d00
      call taper(rr,rr2)
**********************************************************************
*                                                                    *
*     Calculate vdWaals energy                                       *
*                                                                    *
**********************************************************************
      p1=p1co(ity1,ity2)
      p2=p2co(ity1,ity2)
      p3=p3co(ity1,ity2)
      hulpw=(rr**vpar(29)+gamwco(ity1,ity2))
      rrw=hulpw**(1.0d00/vpar(29))
      h1=exp(p3*(1.0d00-rrw/p1))
      h2=exp(0.50d00*p3*(1.0d00-rrw/p1))

      ewh=p2*(h1-2.0d00*h2)
      rrhuw=rr**(vpar(29)-1.0d00)
      dewdr=(p2*p3/p1)*(h2-h1)*rrhuw*(hulpw**(-h15))

**********************************************************************
*                                                                    *
*     Calculate Coulomb energy                                       *
*                                                                    *
**********************************************************************
      q1q2=ch(i1)*ch(i2)
      hulp1=(rr2*rr+gamcco(ity1,ity2))
      eph=c1c*q1q2/(hulp1**third)
      depdr=-c1c*q1q2*rr2/(hulp1**fothird)
**********************************************************************
*                                                                    *
*     Taper correction                                               *
*                                                                    *
**********************************************************************
      ephtap=eph*sw
      depdrtap=depdr*sw+eph*sw1
      ewhtap=ewh*sw
      dewdrtap=dewdr*sw+ewh*sw1

      estrain(i1)=estrain(i1)+0.50d00*(ewhtap+ephtap)
      estrain(i2)=estrain(i2)+0.50d00*(ewhtap+ephtap)
CSN   if (ioutta.eq.1) write (7,'(2i6,3f12.4)')i1,i2,rr,ewhtap,
CSN  $ew+ewhtap
CSN   if (ioutta.eq.1) write (67,'(2i6,3f12.4)')i1,i2,rr,ewhtap,
CSN  $ew+ewhtap
      if (ioutta.eq.1) write (367,'(2i6,3f12.4)')i1,i2,rr,ewhtap,
     $ew+ewhtap
CSN   if (ioutta.eq.1) write (7,'(2i6,5f12.4)')i1,i2,rr,ch(i1),ch(i2)
CSN  $,ephtap,ep+ephtap
CSN   if (ioutta.eq.1) write (68,'(2i6,5f12.4)')i1,i2,rr,ch(i1),ch(i2)
CSN  $,ephtap,ep+ephtap
      if (ioutta.eq.1) write (368,'(2i6,5f12.4)')i1,i2,rr,ch(i1),ch(i2)
     $,ephtap,ep+ephtap
      ew=ew+ewhtap
      ep=ep+ephtap
*     write (64,*)i1,i2,p1,p2,p3,gamwco(ity1,ity2),vpar(29),rr,ewh,ew
**********************************************************************
*                                                                    *
*     Calculate derivatives vdWaals energy to cartesian              *
*     coordinates                                                    *
*                                                                    *
**********************************************************************
      if (icpres.eq.0) then

      do k4=1,3
      d(k4,i1)=d(k4,i1)+(dewdrtap+depdrtap)*(a(k4)/rr)
      d(k4,i2)=d(k4,i2)-(dewdrtap+depdrtap)*(a(k4)/rr)
      end do

      else

      kcell=14+ix+3*iy+9*iz
      do k4=1,3
      dcell(k4,i1,14)=dcell(k4,i1,14)+
     $(dewdrtap+depdrtap)*(a(k4)/rr)
      dcell(k4,i2,kcell)=dcell(k4,i2,kcell)-
     $(dewdrtap+depdrtap)*(a(k4)/rr)
      end do

      end if

   10 continue
**********************************************************************
*                                                                    *
*     Add interaction of atoms with the corresponding atom           *
*     in the surrounding periodic cells                              *
*                                                                    *
**********************************************************************
      do 20 ivl=nvpair-nvlself,nvpair
      i1=nvl1(ivl)
      ix=nvlx(ivl)
      iy=nvly(ivl)
      iz=nvlz(ivl)
      kcell=14+ix+3*iy+9*iz
      a(1)=ix*tm11
      a(2)=ix*tm21+iy*tm22
      a(3)=ix*tm31+iy*tm32+iz*tm33
      rr=sqrt(a(1)*a(1)+a(2)*a(2)+a(3)*a(3))

      if (rr.gt.swb.or.rr.lt.0.001d00) goto 20
      ity1=ia(i1,1)
      rr2=rr*rr

      sw=1.0d00
      sw1=0.0d00
      call taper(rr,rr2)
**********************************************************************
*                                                                    *
*     Calculate vdWaals energy                                       *
*                                                                    *
**********************************************************************
      p1=p1co(ity1,ity1)
      p2=p2co(ity1,ity1)
      p3=p3co(ity1,ity1)

      hulpw=(rr**vpar(29)+gamwco(ity1,ity1))
      rrw=hulpw**(1.0d00/vpar(29))
      h1=exp(p3*(1.0d00-rrw/p1))
      h2=exp(0.50d00*p3*(1.0d00-rrw/p1))

      ewh=0.50d00*p2*(h1-2.0d00*h2)
      rrhuw=rr**(vpar(29)-1.0d00)
      dewdr=0.50d00*(p2*p3/p1)*(h2-h1)*rrhuw*(hulpw**(-h15))
**********************************************************************
*                                                                    *
*     Calculate Coulomb energy                                       *
*                                                                    *
**********************************************************************
      q1q2=ch(i1)*ch(i1)
      hulp1=(rr*rr2+gamcco(ity1,ity1))
      eph=0.50d00*c1c*q1q2/(hulp1**third)
      depdr=-0.50d00*c1c*q1q2*rr2/(hulp1**fothird)
**********************************************************************
*                                                                    *
*     Taper correction                                               *
*                                                                    *
**********************************************************************
      ephtap=eph*sw
      depdrtap=depdr*sw+eph*sw1
      ewhtap=ewh*sw
      dewdrtap=dewdr*sw+ewh*sw1

CSN   if (ioutta.eq.1) write (7,'(2i6,3f12.4)')i1,i1,rr,ewhtap,
CSN  $ew+ewhtap
CSN   if (ioutta.eq.1) write (67,'(2i6,3f12.4)')i1,i1,rr,ewhtap,
CSN  $ew+ewhtap
      if (ioutta.eq.1) write (367,'(2i6,3f12.4)')i1,i1,rr,ewhtap,
     $ew+ewhtap
CSN   if (ioutta.eq.1) write (7,'(2i6,5f12.4)')i1,i1,rr,ch(i1),ch(i2)
CSN  $,ephtap,ep+ephtap
CSN   if (ioutta.eq.1) write (68,'(2i6,5f12.4)')i1,i1,rr,ch(i1),ch(i2)
CSN  $,ephtap,ep+ephtap
      if (ioutta.eq.1) write (368,'(2i6,5f12.4)')i1,i1,rr,ch(i1),ch(i2)
     $,ephtap,ep+ephtap
      ew=ew+ewhtap
      ep=ep+ephtap
      estrain(i1)=estrain(i1)+ewhtap+ephtap

      if (icpres.eq.1) then
      do k4=1,3
      dcell(k4,i1,14)=dcell(k4,i1,14)+
     $(dewdrtap+depdrtap)*(a(k4)/rr)
      dcell(k4,i1,kcell)=dcell(k4,i1,kcell)-
     $(dewdrtap+depdrtap)*(a(k4)/rr)
      end do
      end if

   20 continue

**********************************************************************
*                                                                    *
*     Calculate derivatives Coulomb energy to cartesian              *
*     coordinates                                                    *
*                                                                    *
**********************************************************************

*     do i1=1,na
*     do k1=1,3
*     sum=0.0
*     do 20 i2=1,na

*     do 20 i3=i2+1,na
*     if (dqdc(i3,i1,k1).le.zero.and.dqdc(i2,i1,k1).le.zero)
*    $goto 20
*     rr=rrs(i2,i3)
*     ity1=ia(i2,1)
*     ity2=ia(i3,1)
*     gamt=sqrt(gam(ity1)*gam(ity2))
*     hulp1=(rr**3+(1.0/(gamt**3)))
*     depdq1=-c1c*ch(i3)/(hulp1**third)
*     depdq2=-c1c*ch(i2)/(hulp1**third)
*     sum=sum+depdq1*dqdc(i2,i1,k1)+depdq2*dqdc(i3,i1,k1)
*  20 continue
*     d(i1,k1)=d(i1,k1)+sum

*     end do
*     end do

      if (ioutta.eq.1) then
CSN   close(67)
CSN   close(68)

      CALL SEQCLO(367,'KEEP')
      CALL SEQCLO(368,'KEEP')

      end if
      return

  100 format ('  Atom1 Atom2       R12        EvdW      sum(EvdW)')
  200 format ('  Atom1 Atom2       R12         q1        q2    ',
     $'   E(coulomb)  sum[E(coulomb)]')
      end

********************************************************************** 
**********************************************************************
 
C*MODULE POTEN    *DECK FFEFLD
C> @brief    electric field
C>
C> @details  electric field; coulomb energy
C>
C> @author   Sean Nedd (implementation), Adri van Duin (original author), 2010-2012
C>
C> @date 11-11-14 - Sean A. Nedd
C>
      subroutine ffefld
 
**********************************************************************
      include 'cbka.blk'
      if (ndebug.eq.1) then
CSN   open (65,file='/u1/sean/gamessnew/ffparams/fort.65',
CSN  *      status='unknown',access='append')
CSN   write (65,*) 'In efield'
CSN   call timer(65)
CSN   close (65)

      CALL SEQOPN(365,'FORT65','UNKNOWN',.FALSE.,'FORMATTED')
      write (365,*) 'In efield'
      call timer(365)
      CALL SEQCLO(365,'KEEP')

      end if
**********************************************************************
*                                                                    *
*     Electric field                                                 *
*                                                                    *
**********************************************************************
      efi=0.0d00
      efix=0.0d00
      efiy=0.0d00
      efiz=0.0d00
      c1c=332.0638d00       !Coulomb energy conversion
 
      if (ifieldx.eq.1) then
      do i1=1,na
      efih=vfieldx*23.02d00*c1c*ch(i1)*c(i1,1)
      estrain(i1)=estrain(i1)+efih
      efix=efix+efih
      defidc=23.02d00*c1c*vfieldx*ch(i1)
      d(1,i1)=d(1,i1)+defidc
      end do
      end if
 
      if (ifieldy.eq.1) then
      do i1=1,na
      efih=vfieldy*23.02d00*c1c*ch(i1)*c(i1,2)
      estrain(i1)=estrain(i1)+efih
      efiy=efiy+efih
      defidc=23.02d00*c1c*vfieldy*ch(i1)
      d(2,i1)=d(2,i1)+defidc
      end do
      end if
 
      if (ifieldz.eq.1) then
      do i1=1,na
      efih=vfieldz*23.02d00*c1c*ch(i1)*c(i1,3)
      estrain(i1)=estrain(i1)+efih
      efiz=efiz+efih
      defidc=23.02d00*c1c*vfieldz*ch(i1)
      d(3,i1)=d(3,i1)+defidc
      end do
      end if
 
      efi=efix+efiy+efiz
      return
      end
**********************************************************************
********************************************************************** 

C*MODULE POTEN    *DECK RADBO
C> @brief    radical/double bond energy
C>
C> @details  calculate radical/double bond energy
C>           to increase reaction rates
C>
C> @author   Sean Nedd (implementation), Adri van Duin (original author), 2010-2012
C>
C> @date 11-11-14 - Sean A. Nedd
C>
      subroutine radbo

********************************************************************** 
      include 'cbka.blk'
      dimension a1(3)
********************************************************************** 
*                                                                    *
*     Calculate radical/double bond energy (to increase reaction     *
*     rates)                                                         *
*                                                                    *
********************************************************************** 
      if (ndebug.eq.1) then
CSN   open (65,file='/u1/sean/gamessnew/ffparams/fort.65',
CSN  *      status='unknown',access='append')
CSN   write (65,*) 'In radbo'
CSN   call timer(65)
CSN   close (65)

      CALL SEQOPN(365,'FORT65','UNKNOWN',.FALSE.,'FORMATTED')
      write (365,*) 'In radbo'
      call timer(365)
      CALL SEQCLO(365,'KEEP')

      end if
*     eradbo=zero
*     do i1=1,na
*     if (xmasat(i1).gt.2.0) qa(i1)='C '
*     end do
*     nradcount=nradcount+1
*     if (nradcount.lt.nrddf) return
*     if (nradcount.gt.2*nrddf) nradcount=0

*     do i1=1,nmolo5
*     if (elmol(i1).gt.2*int(elmol(i1)*0.50)) then
*     vlpmax=0.0
*     do i2=1,nmolat2(i1,1)
*     eradmin=50.0
*     ihu=nmolat2(i1,i2+1)
*     if (xmasat(ihu).gt.2.0.and.vlp(ihu).gt.zero) then !no H-atoms
*     vlps=vlp(ihu)

*     do 10 i3=1,na
*     if (xmasat(i3).lt.2.0) goto 10       !no H-atoms
*     imol2=iag(i3,3+mbond)
*     if (i1.eq.imol2) goto 10            !no intermolecular reactions
*     bopisum=zero
*     do i4=1,ia(i3,2)
*     ihu2=nubon2(i3,i4)
*     bopisum=bopisum+bopi(ihu2)
*     end do
*     if (bopisum.lt.0.25) goto 10        !only atoms in double bonds
*     dirb1=dista(ihu,i3)
*     hu1=vpar(22)-dirb1
*     expvl=exp(-5.0*vlps)
*     hexp=1.0-expvl
*     if (hu1.ge.zero) then
*     exphu1=exp(-vpar(25)*hu1*hu1)
*     eradboh1=hexp*vpar(24)*exphu1
*     else
*     exphu1=exp(-vpar(26)*hu1*hu1)
*     eradboh1=hexp*vpar(24)*exphu1
*     end if
*     
*     if (eradboh1.lt.eradmin) then
*     i3s=i3
*     disrmin=dirb1
*     eradmin=eradboh1
*     end if

*  10 continue     

*     qa(ihu)='S '
*     qa(i3s)='N '
*     hu1=vpar(22)-disrmin
*     eradboh1=zero
*     expvl=exp(-5.0*vlps)
*     hexp=1.0-expvl
*     if (hu1.ge.zero) then
*     exphu1=exp(-vpar(25)*hu1*hu1)
*     eradboh1=hexp*vpar(24)*exphu1
*     deradbodr1=hexp*vpar(24)*vpar(25)*2.0*hu1*exphu1
*     else
*     exphu1=exp(-vpar(26)*hu1*hu1)
*     eradboh1=hexp*vpar(24)*exphu1
*     deradbodr1=hexp*vpar(24)*vpar(26)*2.0*hu1*exphu1
*     end if
*     eradbo=eradbo+eradboh1

*     a1(1)=dxm(ihu,i3s)
*     a1(2)=dym(ihu,i3s)
*     a1(3)=dzm(ihu,i3s)

*     do k1=1,3
*     d(k1,ihu)=d(k1,ihu)+deradbodr1*(a1(k1)/disrmin)
*     d(k1,i3s)=d(k1,i3s)-deradbodr1*(a1(k1)/disrmin)
*     end do

*     end if
*     end do

*     end if
*     end do


      return
      end
********************************************************************** 
********************************************************************** 

C*MODULE POTEN    *DECK RESTRAINT
C> @brief    restraint energies
C>
C> @details  calculate restraint energies 
C>
C> @author   Sean Nedd (implementation), Adri van Duin (original author), 2010-2012
C>
C> @date 11-11-14 - Sean A. Nedd
C>
      subroutine restraint

********************************************************************** 
      include 'cbka.blk'
      parameter (msymgroups=20)
      parameter (msymopts=15)
      dimension drda(3),j(4),dhrdc(3,3),dargdc(3,3)
      dimension fc(natf,3),csym(msymopts*natf,3)
      dimension ccsym(msymopts*natf,3)
      dimension cs(natf,3)
      dimension qatsym(msymopts*natf)
      dimension vsymadd(msymgroups,msymopts,3)
      dimension vsymmulx(msymgroups,msymopts,3)
      dimension vsymmuly(msymgroups,msymopts,3)
      dimension vsymmulz(msymgroups,msymopts,3)
      dimension nsymopt(msymgroups)
      dimension qsymm(msymgroups)
      character*2 qatsym
      character*6 qsymm
********************************************************************** 
*                                                                    *
*     Calculate restraint energies                                   *
*                                                                    *
********************************************************************** 
      if (ndebug.eq.1) then
CSN   open (65,file='/u1/sean/gamessnew/ffparams/fort.65',
CSN  *      status='unknown',access='append')
CSN   write (65,*) 'In restraint'
CSN   call timer(65)
CSN   close (65)

      CALL SEQOPN(365,'FORT65','UNKNOWN',.FALSE.,'FORMATTED')
      write (365,*) 'In restraint'
      call timer(365)
      CALL SEQCLO(365,'KEEP')

      end if

      if (nrestras.gt.0) then
********************************************************************** 
*                                                                    *
*     Define symmetry groups                                         *
*                                                                    *
********************************************************************** 
      nsymel=3
      qsymm(1)='    P1'
      nsymopt(1)=1
      vsymadd(1,1,1)=0.0d0          !x=1.0*x   y=1.0*y   z=1.0*z
      vsymadd(1,1,2)=0.0d0
      vsymadd(1,1,3)=0.0d0
      vsymmulx(1,1,1)=1.0d0
      vsymmulx(1,1,2)=0.0d0
      vsymmulx(1,1,3)=0.0d0
      vsymmuly(1,1,1)=0.0d0
      vsymmuly(1,1,2)=1.0d0
      vsymmuly(1,1,3)=0.0d0
      vsymmulz(1,1,1)=0.0d0
      vsymmulz(1,1,2)=1.0d0
      vsymmulz(1,1,3)=0.0d0

      qsymm(2)='   C2V'
      nsymopt(2)=2
      vsymadd(2,1,1)=0.0d0          !x=1.0d0*x   y=1.0*y  z=1.0*z
      vsymadd(2,1,2)=0.0d0
      vsymadd(2,1,3)=0.0d0
      vsymmulx(2,1,1)=1.0d0
      vsymmulx(2,1,2)=0.0d0
      vsymmulx(2,1,3)=0.0d0
      vsymmuly(2,1,1)=0.0d0
      vsymmuly(2,1,2)=1.0d0
      vsymmuly(2,1,3)=0.0d0
      vsymmulz(2,1,1)=0.0d0
      vsymmulz(2,1,2)=0.0d0
      vsymmulz(2,1,3)=1.0d0

      vsymadd(2,2,1)=0.5d0          !x=0.5-1.0d0*y   y=0.5-1.0*x  z=1.0*z
      vsymadd(2,2,2)=0.5d0
      vsymadd(2,2,3)=0.0d0
      vsymmulx(2,2,1)=0.0d0
      vsymmulx(2,2,2)=-1.0d0
      vsymmulx(2,2,3)=0.0d0
      vsymmuly(2,2,1)=-1.0d0
      vsymmuly(2,2,2)=0.0d0
      vsymmuly(2,2,3)=0.0d0
      vsymmulz(2,2,1)=0.0d0
      vsymmulz(2,2,2)=0.0d0
      vsymmulz(2,2,3)=1.0d0

      qsymm(3)='  Pmmm'
      nsymopt(3)=8
      vsymadd(3,1,1)=0.0d0          !x=1.0d0*x   y=1.0*y  z=1.0*z
      vsymadd(3,1,2)=0.0d0
      vsymadd(3,1,3)=0.0d0
      vsymmulx(3,1,1)=1.0d0
      vsymmulx(3,1,2)=0.0d0
      vsymmulx(3,1,3)=0.0d0
      vsymmuly(3,1,1)=0.0d0
      vsymmuly(3,1,2)=1.0d0
      vsymmuly(3,1,3)=0.0d0
      vsymmulz(3,1,1)=0.0d0
      vsymmulz(3,1,2)=0.0d0
      vsymmulz(3,1,3)=1.0d0

      vsymadd(3,2,1)=0.0d0          !x=1.0d0*x   y=-1.0*y  z=1.0*z
      vsymadd(3,2,2)=0.0d0
      vsymadd(3,2,3)=0.0d0
      vsymmulx(3,2,1)=1.0d0
      vsymmulx(3,2,2)=0.0d0
      vsymmulx(3,2,3)=0.0d0
      vsymmuly(3,2,1)=0.0d0
      vsymmuly(3,2,2)=-1.0d0
      vsymmuly(3,2,3)=0.0d0
      vsymmulz(3,2,1)=0.0d0
      vsymmulz(3,2,2)=0.0d0
      vsymmulz(3,2,3)=1.0d0

      vsymadd(3,3,1)=0.0d0          !x=-1.0d0*x   y=1.0*y  z=-1.0*z
      vsymadd(3,3,2)=0.0d0
      vsymadd(3,3,3)=0.0d0
      vsymmulx(3,3,1)=-1.0d0
      vsymmulx(3,3,2)=0.0d0
      vsymmulx(3,3,3)=0.0d0
      vsymmuly(3,3,1)=0.0d0
      vsymmuly(3,3,2)=1.0d0
      vsymmuly(3,3,3)=0.0d0
      vsymmulz(3,3,1)=0.0d0
      vsymmulz(3,3,2)=0.0d0
      vsymmulz(3,3,3)=-1.0d0

      vsymadd(3,4,1)=0.0d0          !x=-1.0d0*x   y=1.0*y  z=1.0*z
      vsymadd(3,4,2)=0.0d0
      vsymadd(3,4,3)=0.0d0
      vsymmulx(3,4,1)=-1.0d0
      vsymmulx(3,4,2)=0.0d0
      vsymmulx(3,4,3)=0.0d0
      vsymmuly(3,4,1)=0.0d0
      vsymmuly(3,4,2)=1.0d0
      vsymmuly(3,4,3)=0.0d0
      vsymmulz(3,4,1)=0.0d0
      vsymmulz(3,4,2)=0.0d0
      vsymmulz(3,4,3)=1.0d0

      vsymadd(3,5,1)=0.0d0          !x=1.0d0*x   y=-1.0*y  z=-1.0*z
      vsymadd(3,5,2)=0.0d0
      vsymadd(3,5,3)=0.0d0
      vsymmulx(3,5,1)=1.0d0
      vsymmulx(3,5,2)=0.0d0
      vsymmulx(3,5,3)=0.0d0
      vsymmuly(3,5,1)=0.0d0
      vsymmuly(3,5,2)=-1.0d0
      vsymmuly(3,5,3)=0.0d0
      vsymmulz(3,5,1)=0.0d0
      vsymmulz(3,5,2)=0.0d0
      vsymmulz(3,5,3)=-1.0d0

      vsymadd(3,6,1)=0.0d0          !x=1.0d0*x   y=1.0*y  z=-1.0*z
      vsymadd(3,6,2)=0.0d0
      vsymadd(3,6,3)=0.0d0
      vsymmulx(3,6,1)=1.0d0
      vsymmulx(3,6,2)=0.0d0
      vsymmulx(3,6,3)=0.0d0
      vsymmuly(3,6,1)=0.0d0
      vsymmuly(3,6,2)=1.0d0
      vsymmuly(3,6,3)=0.0d0
      vsymmulz(3,6,1)=0.0d0
      vsymmulz(3,6,2)=0.0d0
      vsymmulz(3,6,3)=-1.0d0

      vsymadd(3,7,1)=0.0d0          !x=-1.0d0*x   y=-1.0*y  z=1.0*z
      vsymadd(3,7,2)=0.0d0
      vsymadd(3,7,3)=0.0d0
      vsymmulx(3,7,1)=-1.0d0
      vsymmulx(3,7,2)=0.0d0
      vsymmulx(3,7,3)=0.0d0
      vsymmuly(3,7,1)=0.0d0
      vsymmuly(3,7,2)=-1.0d0
      vsymmuly(3,7,3)=0.0d0
      vsymmulz(3,7,1)=0.0d0
      vsymmulz(3,7,2)=0.0d0
      vsymmulz(3,7,3)=1.0d0

      vsymadd(3,8,1)=0.0d0          !x=-1.0d0*x   y=-1.0*y  z=-1.0*z
      vsymadd(3,8,2)=0.0d0
      vsymadd(3,8,3)=0.0d0
      vsymmulx(3,8,1)=-1.0d0
      vsymmulx(3,8,2)=0.0d0
      vsymmulx(3,8,3)=0.0d0
      vsymmuly(3,4,1)=0.0d0
      vsymmuly(3,8,2)=1.0d0
      vsymmuly(3,8,3)=0.0d0
      vsymmulz(3,8,1)=0.0d0
      vsymmulz(3,8,2)=0.0d0
      vsymmulz(3,8,3)=1.0d0

      end if

      do i1=1,nrestra
      ih1=irstra(i1,1)
      ih2=irstra(i1,2)
      if (itend(i1).eq.0.or.(mdstep.gt.itstart(i1).and.mdstep.lt.
     $itend(i1))) then
      call dista2(ih1,ih2,rr,dx,dy,dz)
      diffr=rr-rrstra(i1)
*     diffr=rrstra(i1)
      exphu=exp(-vkrst2(i1)*(diffr*diffr))
      erh=vkrstr(i1)*(1.0d00-exphu)
      deresdr=2.0d00*vkrst2(i1)*diffr*vkrstr(i1)*exphu
*     deresdr=-2.0*vkrst2(i1)*diffr*vkrstr(i1)*exphu
      eres=eres+erh
      drda(1)=dx/rr
      drda(2)=dy/rr
      drda(3)=dz/rr
      do k1=1,3
      d(k1,ih1)=d(k1,ih1)+deresdr*drda(k1)
      d(k1,ih2)=d(k1,ih2)-deresdr*drda(k1)
      end do
      end if
      end do
      
**********************************************************************
*                                                                    *
*     Calculate angle restraint energy                               *
*                                                                    *
**********************************************************************
      do i1=1,nrestrav
      j(1)=irstrav(i1,1)
      j(2)=irstrav(i1,2)
      j(3)=irstrav(i1,3)
      ittr=0
*     do i2=1,nval
*     if (j(1).eq.iv(i2,2).and.j(2).eq.iv(i2,3).and.j(3).eq.iv(i2,4))
*    $ittr=i2
*     end do
*     if (ittr.eq.0) stop 'Wrong valence angle restraint'
      call calvalres(j(1),j(2),j(3),arg,hr,dhrdc,dargdc)
      vaval=hr*rdndgr
      diffv=-(vaval-vrstra(i1))*dgrrdn
      exphu=exp(-vkr2v(i1)*(diffv*diffv))
      erh=vkrv(i1)*(1.0d00-exphu)
      deresdv=-2.0d00*vkr2v(i1)*diffv*vkrv(i1)*exphu
      eres=eres+erh
      do k1=1,3
      do k2=1,3
      d(k1,j(k2))=d(k1,j(k2))+deresdv*dhrdc(k1,k2)
      end do
      end do

      end do

********************************************************************** 
*                                                                    *
*     Calculate torsion restraint energy                             *
*                                                                    *
********************************************************************** 
      do i1=1,nrestrat
      j(1)=irstrat(i1,1)
      j(2)=irstrat(i1,2)
      j(3)=irstrat(i1,3)
      j(4)=irstrat(i1,4)
      ittr=0
      do i2=1,ntor
      if (j(1).eq.it(i2,2).and.j(2).eq.it(i2,3).and.j(3).eq.it(i2,4)
     $.and.j(4).eq.it(i2,5)) ittr=i2
      if (j(4).eq.it(i2,2).and.j(3).eq.it(i2,3).and.j(2).eq.it(i2,4)
     $.and.j(1).eq.it(i2,5)) ittr=i2
      end do
      if (ittr.eq.0) then
      write (*,*)'Wrong torsion restraint'
      write (*,*)i1,j(1),j(2),j(3),j(4)
      stop 'Wrong torsion restraint'
      end if
      vtor=thg(ittr)
      difft=-(vtor-trstra(i1))*dgrrdn
      exphu=exp(-vkr2t(i1)*(difft*difft))
      erh=vkrt(i1)*(1.0d00-exphu)
      deresdt=2.0d00*vkr2t(i1)*difft*vkrt(i1)*exphu
      if (vtor.lt.zero) deresdt=-deresdt
      eres=eres+erh
      do k1=1,3
      do k2=1,4
      d(k1,j(k2))=d(k1,j(k2))+deresdt*dargtdc(ittr,k1,k2)
      end do
      end do

      end do
********************************************************************** 
*                                                                    *
*     Calculate mass centre restraint energy                         *
*                                                                    *
********************************************************************** 
      do i1=1,nrestram
      j1=irstram(i1,2)
      j2=irstram(i1,3)
      j3=irstram(i1,4)
      j4=irstram(i1,5)
      kdir=irstram(i1,1)
      cmx1=0.0d00 
      cmy1=0.0d00 
      cmz1=0.0d00 
      cmx2=0.0d00 
      cmy2=0.0d00 
      cmz2=0.0d00 
      summas1=0.0d00
      summas2=0.0d00
      do i2=j1,j2
      cmx1=cmx1+c(i2,1)*xmasat(i2)
      cmy1=cmy1+c(i2,2)*xmasat(i2)
      cmz1=cmz1+c(i2,3)*xmasat(i2)
      summas1=summas1+xmasat(i2)
      end do
      cmx1=cmx1/summas1
      cmy1=cmy1/summas1
      cmz1=cmz1/summas1
      if (mdstep.lt.2) then
      rmstrax(i1)=cmx1
      rmstray(i1)=cmy1
      rmstraz(i1)=cmz1
      end if
      if (kdir.le.3) then
      do i2=j3,j4
      cmx2=cmx2+c(i2,1)*xmasat(i2)
      cmy2=cmy2+c(i2,2)*xmasat(i2)
      cmz2=cmz2+c(i2,3)*xmasat(i2)
      summas2=summas2+xmasat(i2)
      end do
      cmx2=cmx2/summas2
      cmy2=cmy2/summas2
      cmz2=cmz2/summas2
      end if
      if (kdir.eq.1) dist=cmx1-cmx2
      if (kdir.eq.2) dist=cmy1-cmy2
      if (kdir.eq.3) dist=cmz1-cmz2
      if (kdir.eq.4) then
      distx=cmx1-rmstrax(i1)
      disty=cmy1-rmstray(i1)
      distz=cmz1-rmstraz(i1)
      dist=sqrt(distx*distx+disty*disty+distz*distz)
      end if
      dismacen(i1)=dist
      dist=dist-rmstra1(i1)
      erh=rmstra2(i1)*dist*dist
      deresdr=2.0d00*dist*rmstra2(i1)
*     exphu=exp(-rmstra3(i1)*(dist*dist))
*     erh=rmstra2(i1)*(1.0d00-exphu)
*     deresdr=2.0d00*rmstra3(i1)*dist*rmstra2(i1)*exphu
      eres=eres+erh
      if (kdir.le.3) then
      do i2=j1,j2
      d(kdir,i2)=d(kdir,i2)+deresdr*xmasat(i2)/summas1
      end do
      do i2=j3,j4
      d(kdir,i2)=d(kdir,i2)-deresdr*xmasat(i2)/summas2
      end do
      end if
      if (kdir.eq.4.and.mdstep.gt.5) then
      do i2=j1,j2
      d(1,i2)=d(1,i2)+deresdr*(distx/dist)*(xmasat(i2)/summas1)
      d(2,i2)=d(2,i2)+deresdr*(disty/dist)*(xmasat(i2)/summas1)
      d(3,i2)=d(3,i2)+deresdr*(distz/dist)*(xmasat(i2)/summas1)
      end do
      end if
      end do
********************************************************************** 
*                                                                    *
*     Calculate symmetry restraint energy                            *
*                                                                    *
********************************************************************** 
      if (nrestras.gt.0) then
********************************************************************** 
*                                                                    *
*     Convert to fractional coordinates                              *
*                                                                    *
********************************************************************** 
*     write (67,'(f12.8)')c(1,1)
      do i1=1,na
      fc(i1,1)=c(i1,1)/tm11
      fc(i1,2)=(c(i1,2)-tm21*fc(i1,1))/tm22
      fc(i1,3)=(c(i1,3)-tm31*fc(i1,1)-tm32*fc(i1,2))/tm33
      end do
********************************************************************** 
*                                                                    *
*     Move system to origin                                          *
*                                                                    *
********************************************************************** 

      vxmin=1000.0d00
      vymin=1000.0d00
      vzmin=1000.0d00

      do i1=1,na
      if (fc(i1,1).lt.vxmin) vxmin=fc(i1,1)
      if (fc(i1,2).lt.vymin) vymin=fc(i1,2)
      if (fc(i1,3).lt.vzmin) vzmin=fc(i1,3)
      end do

      do i1=1,na
      fc(i1,1)=fc(i1,1)-vxmin
      fc(i1,2)=fc(i1,2)-vymin
      fc(i1,3)=fc(i1,3)-vzmin
      end do

      do i1=1,na
      fc(i1,1)=fc(i1,1)-int(fc(i1,1))
      fc(i1,2)=fc(i1,2)-int(fc(i1,2))
      fc(i1,3)=fc(i1,3)-int(fc(i1,3))
      end do

********************************************************************** 
*                                                                    *
*     Convert back to cartesian coordinates                          *
*                                                                    *
********************************************************************** 
      do i2=1,na
      cs(i2,1)=fc(i2,1)*tm11
      cs(i2,2)=fc(i2,1)*tm21+fc(i2,2)*tm22
      cs(i2,3)=fc(i2,1)*tm31+fc(i2,2)*tm32+fc(i2,3)*tm33
      end do

*     write (67,'(2f12.8)')c(1,1),cs(i1,1)
      do i1=1,nrestras
      isymel=0
      do i2=1,nsymel
      if (qrstras(i1).eq.qsymm(i2)) isymel=i2
      end do
      if (isymel.eq.0) then
      write (*,*)qrstras(i1),nrestras,irstras(1,1)
      write (*,*)'Unknown symmetry element'
      stop 'Unknown symmetry element'
      end if
********************************************************************** 
*                                                                    *
*     Construct symmetry images                                      *
*                                                                    *
********************************************************************** 
      natsym=0
      do i2=1,nsymopt(isymel)
      do i3=1,irstras(i1,1)
      iatsy=irstras(i1,1+i3)
      csym(natsym+1,1)=vsymadd(isymel,i2,1)+
     $vsymmulx(isymel,i2,1)*fc(iatsy,1)+
     $vsymmulx(isymel,i2,2)*fc(iatsy,2)+
     $vsymmulx(isymel,i2,3)*fc(iatsy,3)
      csym(natsym+1,2)=vsymadd(isymel,i2,2)+
     $vsymmuly(isymel,i2,1)*fc(iatsy,1)+
     $vsymmuly(isymel,i2,2)*fc(iatsy,2)+
     $vsymmuly(isymel,i2,3)*fc(iatsy,3)
      csym(natsym+1,3)=vsymadd(isymel,i2,3)+
     $vsymmulz(isymel,i2,1)*fc(iatsy,1)+
     $vsymmulz(isymel,i2,2)*fc(iatsy,2)+
     $vsymmulz(isymel,i2,3)*fc(iatsy,3)
      qatsym(natsym+1)=qa(iatsy)
********************************************************************** 
*                                                                    *
*     Put image back in unit cell                                    *
*                                                                    *
********************************************************************** 
      do i4=1,3
      if (csym(natsym+1,i4).gt.1.0d00) 
     $csym(natsym+1,i4)=csym(natsym+1,i4)-1.0d0
      if (csym(natsym+1,i4).lt.zero) 
     $csym(natsym+1,i4)=csym(natsym+1,i4)+1.0d0
      if (csym(natsym+1,i4).gt.0.99d00) 
     $csym(natsym+1,i4)=csym(natsym+1,i4)-1.0d0
      end do
 
********************************************************************** 
*                                                                    *
*     Check overlap with existing images                             *
*                                                                    *
********************************************************************** 
      dismin=1000.00d00
      do i4=1,natsym
      dx=csym(natsym+1,1)-csym(i4,1)
      dy=csym(natsym+1,2)-csym(i4,2)
      dz=csym(natsym+1,3)-csym(i4,3)
      dx=dx-int(dx)
      dy=dy-int(dy)
      dz=dz-int(dz)

      dissym=sqrt(dx*dx+dy*dy+dz*dz)
      if (dissym.lt.dismin) dismin=dissym
      end do
      if (dismin.gt.0.10d00) then
      natsym=natsym+1   !Accept new image
      end if

      end do
      end do
**********************************************************************
*                                                                    *
*     Move system to origin                                          *
*                                                                    *
**********************************************************************
*     do i2=1,natsym
*     write (67,'(a2,3f12.8)')qatsym(i2),
*    $csym(i2,1)*tm11,csym(i2,2),csym(i2,3)
*     end do
*     write (67,*)'2'

      vxmin=1000.0d00
      vymin=1000.0d00
      vzmin=1000.0d00

      do i2=1,natsym
      if (csym(i2,1).lt.vxmin) vxmin=csym(i2,1)
      if (csym(i2,2).lt.vymin) vymin=csym(i2,2)
      if (csym(i2,3).lt.vzmin) vzmin=csym(i2,3)
      end do

      do i2=1,natsym
      csym(i2,1)=csym(i2,1)-vxmin
      csym(i2,2)=csym(i2,2)-vymin
      csym(i2,3)=csym(i2,3)-vzmin
      end do

      do i2=1,natsym
      csym(i2,1)=csym(i2,1)-int(csym(i2,1))
      csym(i2,2)=csym(i2,2)-int(csym(i2,2))
      csym(i2,3)=csym(i2,3)-int(csym(i2,3))
      end do

*     do i2=1,natsym
*     write (67,'(a2,3f12.8)')qatsym(i2),
*    $csym(i2,1),csym(i2,2),csym(i2,3)
*     end do
*     write (67,*)'3'
********************************************************************** 
*                                                                    *
*     Convert symmetric images to cartesian coordinates              *
*                                                                    *
********************************************************************** 
      do i2=1,natsym
      ccsym(i2,1)=csym(i2,1)*tm11
      ccsym(i2,2)=csym(i2,1)*tm21+csym(i2,2)*tm22
      ccsym(i2,3)=csym(i2,1)*tm31+csym(i2,2)*tm32+csym(i2,3)*tm33
      end do
********************************************************************** 
*                                                                    *
*     Shift symmetric images back to original location               *
*                                                                    *
********************************************************************** 
*     dxs=ccsym(irstras(i1,2),1)-cs(irstras(i1,2),1)
*     dys=ccsym(irstras(i1,2),2)-cs(irstras(i1,2),2)
*     dzs=ccsym(irstras(i1,2),3)-cs(irstras(i1,2),3)

*     do i2=1,natsym
*     ccsym(i2,1)=ccsym(i2,1)-dxs
*     ccsym(i2,2)=ccsym(i2,2)-dys
*     ccsym(i2,3)=ccsym(i2,3)-dzs
*     end do

*     write (67,'(3f12.8)')c(1,1),cs(i1,1),csym(1,1)
*     do i2=1,natsym
*     write (67,'(a2,3f12.8)')qatsym(i2),
*    $ccsym(i2,1),ccsym(i2,2),ccsym(i2,3)
*     end do
*     write (67,*)
*     do i2=1,na
*     write (67,'(a2,3f12.8)')qa(i2),
*    $cs(i2,1),cs(i2,2),cs(i2,3)
*     end do
*     write (67,*)
********************************************************************** 
*                                                                    *
*     Find closest symmetric image to coordinates                    *
*     Calculate restraint energy and force                           *
*                                                                    *
********************************************************************** 
      sysdissum(i1)=zero
      do i2=1,na
      distmin=1000.00d00
      nclose=0
      do i3=1,natsym
      disx=cs(i2,1)-ccsym(i3,1)
      disy=cs(i2,2)-ccsym(i3,2)
      disz=cs(i2,3)-ccsym(i3,3)
      dist=sqrt(disx*disx+disy*disy+disz*disz)
      if (dist.lt.distmin) then
      nclose=i3
      dxclose=disx
      dyclose=disy
      dzclose=disz
      distmin=dist
      end if
      end do

      sysdissum(i1)=sysdissum(i1)+distmin
      exphu=exp(-vksym2(i1)*(distmin*distmin))
      erh=vksym1(i1)*(1.0d00-exphu)
      deresdr=2.0d00*vksym2(i1)*distmin*vksym1(i1)*exphu
      eres=eres+erh
*     write (67,*)i2,nclose,distmin,erh,eres,deresdr
      drda(1)=dxclose
      drda(2)=dyclose
      drda(3)=dzclose
      do k1=1,3
      d(k1,i2)=d(k1,i2)+deresdr*drda(k1)
      end do

      end do


      end do

      do i1=1,na
      do i2=1,3
      c(i1,i2)=cs(i1,i2)
      end do
      end do

      end if
********************************************************************** 
*                                                                    *
*     Calculate morphing energy                                      *
*                                                                    *
********************************************************************** 
      if (imorph.eq.1) then
      distot=zero
      do i1=1,na
      dmx=c(i1,1)-cmo(i1,1)
      dmy=c(i1,2)-cmo(i1,2)
      dmz=c(i1,3)-cmo(i1,3)
      dism=sqrt(dmx*dmx+dmy*dmy+dmz*dmz)
      distot=distot+dism
*     exphu=exp(-vmo2(i1)*(dism*dism))
*     erh=vmo1(i1)*(1.0-exphu)
      erh=vmo1(i1)*dism
      eres=eres+erh
*     deresddis=2.0*vmo2(i1)*dism*vmo1(i1)*exphu
      deresddis=vmo1(i1)
      drda1=dmx/dism
      drda2=dmy/dism
      drda3=dmz/dism
      d(1,i1)=d(1,i1)+deresddis*drda1
      d(2,i1)=d(2,i1)+deresddis*drda2
      d(3,i1)=d(3,i1)+deresddis*drda3
      end do
CSN   write (65,'(i6,6f12.4)')mdstep,distot,eres
      write (365,'(i6,6f12.4)')mdstep,distot,eres
  
      end if
      
      
      return
      end
********************************************************************** 
********************************************************************** 

C*MODULE POTEN    *DECK PISTON
C> @brief    piston interactions
C>
C> @details  calculate interactions with flat piston
C>
C> @author   Sean Nedd (implementation), Adri van Duin (original author), 2010-2012
C>
C> @date 11-11-14 - Sean A. Nedd
C>
      subroutine piston

********************************************************************** 
      include 'cbka.blk'
*     dimension drda(3),j(4),dhrdc(3,3),dargdc(3,3)
********************************************************************** 
*                                                                    *
*     Calculate interactions with flat piston                        *
*     edeep:  Piston magnitude U=8*Edeep/(Rdeep+R^6)                 *
*     rdeep:  1:barrier equals Edeep at distance R=0                 *
*             0:infinite barrier at distance R=0                     *
*     pshft:  piston shift from left side of supercell               *
*     azm:    Location left side of supercell                        *
*     rcut:   Piston width                                           *
*     ipdir:  1: piston in x;2: piston in y;3: piston in z-direction *
*                                                                    *
********************************************************************** 
      if (ndebug.eq.1) then
CSN   open (65,file='/u1/sean/gamessnew/ffparams/fort.65',
CSN  *      status='unknown',access='append')
CSN   write (65,*) 'In piston'
CSN   call timer(65)
CSN   close (65)

      CALL SEQOPN(365,'FORT65','UNKNOWN',.FALSE.,'FORMATTED')
      write (365,*) 'In piston'
      call timer(365)
      CALL SEQCLO(365,'KEEP')

      end if
     
      epist=zero
      azm=zero 
      if (icentr.eq.1) then
      azm=zero 
      else if (icentr.eq.2) then
      if (ipdir.eq.1) azm= -axiss(1)/2.0d00
      if (ipdir.eq.2) azm= -axiss(2)/2.0d00
      if (ipdir.eq.3) azm= -axiss(3)/2.0d00
      end if

      apist0=azm+pshft
      apist1=azm+pshft+rcut
      edeep6=edeep/6.0d00

*     write (64,*)mdstep,edeep6,ipdir,apist1,apist0
      do i1=1,na
      episth=zero
      depistdr=zero
      if (c(i1,ipdir).lt.apist1) then
      dist=c(i1,ipdir)-apist0
      if (dist.gt.zero) then
      rcube=dist*dist*dist
      episth=2.0d00*edeep6/(rcube+rdeep)
      depistdr=-dist*dist*edeep/((rcube+rdeep)*(rcube+rdeep))
      end if
      end if
  
      depistdc=depistdr
      epist=epist+episth
      d(ipdir,i1)=d(ipdir,i1)+depistdc

      end do

      if (mod(mdstep,nrep1).eq.0) then

CSN   open (81,file='/u1/sean/gamessnew/ffparams/fort.81',
CSN  *      status='unknown',access='append')
CSN   write (81,100)mdstep,epist
CSN   close (81)

      CALL SEQOPN(381,'FORT81','UNKNOWN',.FALSE.,'FORMATTED')
      write (381,100)mdstep,epist
      CALL SEQCLO(381,'KEEP')

      end if

      return
  100 format (i8,f20.5)
      end
******************************************************************** 
******************************************************************** 

C*MODULE POTEN    *DECK CALVALRES
C> @brief    valency angles and gradients for restraint calculations
C>
C> @details  calculate valency angles and their derivatives to cartesian
C>           coordinates  for restraint calculations
C>
C> @author   Sean Nedd (implementation), Adri van Duin (original author), 2010-2012
C>
C> @date 11-11-14 - Sean A. Nedd
C>
C> @param   ja1    : atom 1 
C> @param   ja2    : atom 2
C> @param   ja3    : atom 3
C> @param   arg    : cos(valence angle) 
C> @param   hr     : valence angle
C> @param   dhrdc  : derivative valence angle in cartesians 
C> @param   dargdc : derivative cos(valence angle) in cartesians 
C>
      subroutine calvalres (ja1,ja2,ja3,arg,hr,dhrdc,dargdc)

********************************************************************** 
      include 'cbka.blk'
      dimension a(3),b(3),j(3),dradc(3,3),drbdc(3,3),dtdc(3,3),
     $dargdc(3,3),dndc(3,3),dadc(3),dbdc(3),dhrdc(3,3)
********************************************************************** 
*                                                                    *
*     Calculate valency angles and their derivatives to cartesian    *
*     coordinates  for restraint calculations                        *
*                                                                    *
********************************************************************** 
*     if (ndebug.eq.1) then
*     open (65,file='fort.65',status='unknown',access='append')
*     write (65,*) 'In calvalres'
*     call timer(65)
*     close (65)
*     end if

      dadc(1)=-1.0d00
      dadc(2)=1.0d00
      dadc(3)=0.0d00
      dbdc(1)=0.0d00
      dbdc(2)=1.0d00
      dbdc(3)=-1.0d00
      do k1=1,3
      do k2=1,3
      dradc(k1,k2)=0.0d00
      drbdc(k1,k2)=0.0d00
      end do
      end do
**********************************************************************
*                                                                    *
*     Determine valency angle                                        *
*                                                                    *
**********************************************************************
      call dista2(ja1,ja2,rla,dx1,dy1,dz1)
      call dista2(ja2,ja3,rlb,dx2,dy2,dz2)
 
      a(1)=-dx1
      a(2)=-dy1
      a(3)=-dz1
      b(1)=dx2
      b(2)=dy2
      b(3)=dz2
      poem=rla*rlb
      tel=a(1)*b(1)+a(2)*b(2)+a(3)*b(3)
      arg=tel/poem
      arg2=arg*arg
      s1ma22=1.0d00-arg2
      if (s1ma22.lt.1.0d-10) s1ma22=1.0d-10
      s1ma2=sqrt(s1ma22)
      if (arg.gt.1.0d00) arg=1.0d00
      if (arg.lt.-1.0d00) arg=-1.0d00
      hr=acos(arg)
**********************************************************************
*                                                                    *
*     Calculate derivative valency angle to cartesian coordinates    *
*                                                                    *
**********************************************************************
      do k1=1,3
      dradc(k1,1)=-a(k1)/rla
      dradc(k1,2)=a(k1)/rla
      end do

      do k1=1,3
      drbdc(k1,2)=b(k1)/rlb
      drbdc(k1,3)=-b(k1)/rlb
      end do

      do k1=1,3
      do k2=1,3
      dndc(k1,k2)=rla*drbdc(k1,k2)+rlb*dradc(k1,k2)
      dtdc(k1,k2)=a(k1)*dbdc(k2)+b(k1)*dadc(k2)
      dargdc(k1,k2)=(dtdc(k1,k2)-arg*dndc(k1,k2))/poem
      dhrdc(k1,k2)=-dargdc(k1,k2)/s1ma2
      end do
      end do
      
   10 continue

      return
      end
********************************************************************** 
******************************************************************** 

C*MODULE POTEN    *DECK CALVALHB
C> @brief    valency angles and derivatives for H-bond calculations
C>
C> @details  calculate valency angles and their derivatives to cartesian
C>           coordinates  for hydrogen bond calculations
C>
C> @author   Sean Nedd (implementation), Adri van Duin (original author), 2010-2012
C>
C> @date 11-11-14 - Sean A. Nedd
C>
C> @param   ja1    : atom 1
C> @param   ja2    : atom 2
C> @param   ja3    : atom 3
C> @param   ix     : x component in hydrogen bond
C> @param   iy     : y component in hydrogen bond
C> @param   iz     : z component in hydrogen bond
C> @param   arg    : cos(valence angle)
C> @param   hr     : valence angle with hydrogen bond assessed
C> @param   dhrdc  : derivative valence angle in cartesians                          
C> @param   dargdc : derivative cos(valence angle) in cartesians
C>
      subroutine calvalhb (ja1,ja2,ja3,ix,iy,iz,arg,hr,dhrdc,dargdc)

********************************************************************** 
      include 'cbka.blk'
      dimension a(3),b(3),j(3),dradc(3,3),drbdc(3,3),dtdc(3,3),
     $dargdc(3,3),dndc(3,3),dadc(3),dbdc(3),dhrdc(3,3)
********************************************************************** 
*                                                                    *
*     Calculate valency angles and their derivatives to cartesian    *
*     coordinates  for hydrogen bond calculations                    *
*                                                                    *
********************************************************************** 
*     if (ndebug.eq.1) then
*     open (65,file='fort.65',status='unknown',access='append')
*     write (65,*) 'In calvalhb'
*     call timer(65)
*     close (65)
*     end if

      dadc(1)=-1.0d00
      dadc(2)=1.0d00
      dadc(3)=0.0d00
      dbdc(1)=0.0d00
      dbdc(2)=1.0d00
      dbdc(3)=-1.0d00
      do k1=1,3
      do k2=1,3
      dradc(k1,k2)=0.0d00
      drbdc(k1,k2)=0.0d00
      end do
      end do
**********************************************************************
*                                                                    *
*     Determine valency angle                                        *
*                                                                    *
**********************************************************************
      call dista2(ja1,ja2,rla,dx1,dy1,dz1)
      dx2=c(ja2,1)-c(ja3,1)+ix*tm11
      dy2=c(ja2,2)-c(ja3,2)+ix*tm21+iy*tm22
      dz2=c(ja2,3)-c(ja3,3)+ix*tm31+iy*tm32+iz*tm33
      rlb=sqrt(dx2*dx2+dy2*dy2+dz2*dz2)

      a(1)=-dx1
      a(2)=-dy1
      a(3)=-dz1
      b(1)=dx2
      b(2)=dy2
      b(3)=dz2
      poem=rla*rlb
      tel=a(1)*b(1)+a(2)*b(2)+a(3)*b(3)
      arg=tel/poem
      arg2=arg*arg
      s1ma22=1.0d00-arg2
      if (s1ma22.lt.1.0d-10) s1ma22=1.0d-10
      s1ma2=sqrt(s1ma22)
      if (arg.gt.1.0d00) arg=1.0d00
      if (arg.lt.-1.0d00) arg=-1.0d00
      hr=acos(arg)
**********************************************************************
*                                                                    *
*     Calculate derivative valency angle to cartesian coordinates    *
*                                                                    *
**********************************************************************
      do k1=1,3
      dradc(k1,1)=-a(k1)/rla
      dradc(k1,2)=a(k1)/rla
      end do

      do k1=1,3
      drbdc(k1,2)=b(k1)/rlb
      drbdc(k1,3)=-b(k1)/rlb
      end do

      do k1=1,3
      do k2=1,3
      dndc(k1,k2)=rla*drbdc(k1,k2)+rlb*dradc(k1,k2)
      dtdc(k1,k2)=a(k1)*dbdc(k2)+b(k1)*dadc(k2)
      dargdc(k1,k2)=(dtdc(k1,k2)-arg*dndc(k1,k2))/poem
      dhrdc(k1,k2)=-dargdc(k1,k2)/s1ma2
      end do
      end do
      
   10 continue

      return
      end
********************************************************************** 
********************************************************************** 

C*MODULE POTEN    *DECK CALTOR
C> @brief    torsion angle
C>
C> @details  calculate torsion angle (for internal coordinates output)
C>
C> @author   Sean Nedd (implementation), Adri van Duin (original author), 2010-2012
C>
C> @date 11-11-14 - Sean A. Nedd
C>
C> @param   ja1    : atom 1
C> @param   ja2    : atom 2
C> @param   ja3    : atom 3
C> @param   ja4    : atom 4
C> @param   ht     : torsion angle
C>
      subroutine caltor(ja1,ja2,ja3,ja4,ht)

********************************************************************** 
      include 'cbka.blk'
      DIMENSION  A(3),DRDA(3),DADC(4),DRADC(3,4),DRBDC(3,4),
     $DRCDC(3,4),DHDDC(3,4),DHEDC(3,4),DRVDC(3,4),DTDC(3,4),
     $DNDC(3,4)
      dimension j(4),dvdc1(3,3),dargdc1(3,3),dvdc2(3,3),dargdc2(3,3)
********************************************************************** 
*                                                                    *
*     Calculate torsion angle (for internal coordinates output)      *
*                                                                    *
********************************************************************** 
      if (ndebug.eq.1) then
CSN   open (65,file='/u1/sean/gamessnew/ffparams/fort.65',
CSN  *      status='unknown',access='append')
CSN   write (65,*) 'In caltor'
CSN   call timer(65)
CSN   close (65)

      CALL SEQOPN(365,'FORT65','UNKNOWN',.FALSE.,'FORMATTED')
      write (365,*) 'In caltor'
      call timer(365)
      CALL SEQCLO(365,'KEEP')

      end if
      do k1=1,3
      do k2=1,4
      dhddc(k1,k2)=0.0d00
      dhedc(k1,k2)=0.0d00
      dradc(k1,k2)=0.0d00
      drbdc(k1,k2)=0.0d00
      drcdc(k1,k2)=0.0d00
      end do
      end do
      et=0.0d00
      eco=0.0d00
      dadc(1)=1.0d00
      dadc(2)=0.0d00
      dadc(3)=0.0d00
      dadc(4)=-1.0d00
      call dista2(ja1,ja2,rla,dx1,dy1,dz1)
      call dista2(ja2,ja3,rlb,dx2,dy2,dz2)
      call dista2(ja3,ja4,rlc,dx2,dy2,dz2)
      call dista2(ja1,ja4,r4,dx2,dy2,dz2)
      call calvalres(ja1,ja2,ja3,arg1,h1,dvdc1,dargdc1)
      call calvalres(ja2,ja3,ja4,arg2,h2,dvdc2,dargdc2)
********************************************************************** 
*                                                                    *
*     Determine torsion angle                                        *
*                                                                    *
********************************************************************** 
      d142=r4*r4
      coshd=cos(h1)
      coshe=cos(h2)
      sinhd=sin(h1)
      sinhe=sin(h2)
      poem=2.0d00*rla*rlc*sinhd*sinhe
      poem2=poem*poem
      tel=rla*rla+rlb*rlb+rlc*rlc-d142-2.0d00*(rla*rlb*coshd-rla*rlc*
     $coshd*coshe+rlb*rlc*coshe)
      arg=tel/poem
      if (arg.gt.1.0d00) arg=1.0d00
      if (arg.lt.-1.0d00) arg=-1.0d00
      arg2=arg*arg
      ht=acos(arg)*rdndgr
      k1=ja1
      k2=ja2
      k3=ja3
      k4=ja4
      call dista2(k3,k2,dis,x3,y3,z3)
      y32z32=y3*y3+z3*z3
      wort1=sqrt(y32z32)+1d-6
      wort2=sqrt(y32z32+x3*x3)+1d-6
      sinalf=y3/wort1
      cosalf=z3/wort1
      sinbet=x3/wort2
      cosbet=wort1/wort2
      call dista2(k1,k2,dis,x1,y1,z1)
      x1=x1*cosbet-y1*sinalf*sinbet-z1*cosalf*sinbet
      y1=y1*cosalf-z1*sinalf
      wort3=sqrt(x1*x1+y1*y1)+1d-6
      singam=y1/wort3
      cosgam=x1/wort3
      call dista2(k4,k2,dis,x4,y4,z4)
      x4=x4*cosbet-y4*sinalf*sinbet-z4*cosalf*sinbet
      y4=y4*cosalf-z4*sinalf
      y4=x4*singam-y4*cosgam
      if (y4.gt.0.0d00) ht=-ht
      if (ht.lt.-179.999999d0) ht=-179.999999d0
      if (ht.gt.179.999999d0) ht=179.999999d0

      return
      end 
********************************************************************** 
********************************************************************** 
